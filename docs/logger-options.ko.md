# Codebot 로깅 옵션 가이드

본 문서는 Codebot의 로깅 옵션(-v, --verbose 및 -d, --debug)이 어떻게 동작하는지 설명합니다.

## 로깅 시스템 개요

Codebot은 중앙 집중식 로깅 시스템을 사용하여 애플리케이션 전체에서 일관된 로깅을 제공합니다. 이 시스템은 `src/utils/logger.ts`의 `Logger` 클래스를 통해 구현됩니다.

## CLI 옵션

Codebot CLI는 다음과 같은 로깅 관련 옵션을 제공합니다:

### 기본 옵션
- `-v, --verbose`: 상세 로깅을 활성화합니다. 프로그램 실행 과정의 세부 단계를 출력합니다.
- `-d, --debug`: 디버그 모드를 활성화합니다. 오류 상세 정보 및 내부 상태를 출력합니다.

### AI 스트리밍 관련 옵션
- `-a, --ai-stream`: 모든 노드에 대한 AI 스트림 출력을 활성화합니다.
- `--stream-nodes <nodes>`: AI 스트림을 표시할 노드 목록을 쉼표로 구분하여 지정합니다.
- `--hide-stream-nodes <nodes>`: AI 스트림을 숨길 노드 목록을 쉼표로 구분하여 지정합니다.

## 동작 방식

### 옵션 처리 흐름
1. CLI에서 사용자가 옵션 지정
2. 명령어 핸들러에서 옵션 파싱
3. `Logger.configure()` 메서드를 통해 로깅 설정 구성
4. 설정된 값에 따라 각 로깅 메서드가 출력 여부 결정

### 각 옵션의 영향 범위

#### verbose 옵션
- 노드 진입/종료 메시지 출력
- 노드 액션 로깅
- 모델 활동 시작/종료 로깅

다음과 같은 메서드에 영향을 미칩니다:
- `Logger.nodeEntry()`
- `Logger.nodeAction()`
- `Logger.nodeModelStart()`
- `Logger.nodeExit()`

#### debug 옵션
- 오류 객체의 상세 정보 출력
- 디버그 메시지 및 데이터 출력
- 그래프 상태 로깅 활성화
- 특정 조건에서 AI 스트림 표시 활성화

다음과 같은 메서드에 영향을 미칩니다:
- `Logger.error()` (오류 객체 출력)
- `Logger.debug()`
- `Logger.graphState()`
- `Logger._isStreamingVisibleForNode()` (간접적 영향)

#### aiStream 옵션
- 모든 노드의 AI 스트리밍 출력 표시 여부 제어
- 노드 모델 스트리밍 표시에 직접적인 영향

다음 메서드에 영향을 미칩니다:
- `Logger.nodeModelStreaming()`

#### nodeStreamConfig / stream-nodes / hide-stream-nodes
- 특정 노드에 대한 스트리밍 표시 여부를 개별적으로 설정
- 전역 AI 스트림 설정보다 우선 적용됨

## 예제

### 기본 사용

```bash
# 기본 실행 (최소 로깅)
codebot chat

# 상세 로깅 활성화
codebot chat --verbose

# 디버그 모드 활성화
codebot chat --debug

# 상세 로깅과 디버그 모드 모두 활성화
codebot chat --verbose --debug
```

### AI 스트리밍 제어

```bash
# 모든 노드의 AI 스트림 출력 활성화
codebot chat --ai-stream

# 특정 노드의 AI 스트림만 표시
codebot chat --stream-nodes translateInput,executeStep

# 특정 노드의 AI 스트림만 숨기기
codebot chat --ai-stream --hide-stream-nodes retrieveDocuments,summarizeResponse
```

### 기본적으로 모든 노드의 AI 스트림 활성화하기

모든 노드에서 AI 스트림 출력을 기본적으로 활성화하려면 다음과 같이 설정할 수 있습니다:

1. 설정 파일 수정:
   - `~/.codebot/config.json` 파일을 열어 기본 로깅 설정 추가:

```json
{
  "providers": [...],
  "defaultProvider": "...",
  "language": "ko",
  "logging": {
    "defaultAiStream": true,
    "alwaysVisibleNodes": ["translateInput", "executeStep"]
  }
}
```

2. 코드에서 `Logger.configure()` 호출 전에 설정 적용:

```typescript
// src/cli/index.ts 수정
// Logger 설정 전에 설정 파일에서 로깅 값 가져오기
const configManager = new ConfigManager();
configManager.loadConfig();
const loggingConfig = configManager.getLoggingConfig();

// Logger 설정
Logger.configure({
  verbose: !!options.verbose,
  debug: !!options.debug,
  // 설정 파일의 기본값과 명령줄 옵션 결합
  aiStream: loggingConfig?.defaultAiStream || !!options.aiStream,
  graphState: !!options.debug,
  tools: true,
  nodeStreamConfig,
  // 설정 파일에 지정된 항상 표시할 노드 목록 적용
  alwaysVisibleNodes: loggingConfig?.alwaysVisibleNodes
});
```

3. 설정 파일 없이 콘솔 명령으로 일시적으로 실행 시:

```bash
# 한 번의 실행에서 모든 노드의 AI 스트림 출력 활성화
codebot chat --ai-stream

# 특별한 경우 환경 변수 사용 (일회성)
CODEBOT_AI_STREAM=true codebot chat
```

## 일관된 로깅 체계 적용하기

### Logger를 사용하지 않는 코드 식별 및 대응

현재 코드베이스에서 직접적으로 `console.log`를 사용하는 경우와 `Logger` 클래스를 사용하는 경우가 혼재되어 있을 수 있습니다. 이를 통일하기 위한 방법은 다음과 같습니다:

#### 1. 기존 console.log 호출 식별

프로젝트 전체에서 `console.log` 직접 호출을 검색합니다:

```bash
# Unix/Linux/macOS
grep -r "console\.log" --include="*.ts" --include="*.js" ./src

# Windows PowerShell
Get-ChildItem -Path ./src -Include *.ts,*.js -Recurse | Select-String "console\.log"
```

#### 2. Logger 래퍼 함수 추가

기존 콘솔 출력을 Logger로 래핑하는 유틸리티 함수를 추가합니다:

```typescript
// src/utils/console-utils.ts
import { Logger } from './logger.js';

/**
 * console.log를 Logger로 래핑하는 함수
 * @param message 로깅할 메시지
 * @param data 추가 데이터
 *
 * Generated by Copilot
 */
export function logInfo(message: string, data?: any): void {
  // 직접 콘솔에 출력하되, verbose 모드일 때만 상세 정보 포함
  console.log(message);
  if (data && Logger.isVerbose()) {
    console.log(data);
  }

  // 필요시 로깅 시스템에도 기록
  Logger.debug(`[INFO] ${message}`, data);
}

/**
 * console.error를 Logger로 래핑하는 함수
 * @param message 오류 메시지
 * @param error 오류 객체
 *
 * Generated by Copilot
 */
export function logError(message: string, error?: any): void {
  Logger.error(message, error);
}
```

#### 3. Logger.ts에 isVerbose(), isDebug() 메서드 추가

```typescript
// src/utils/logger.ts에 추가
/**
 * verbose 모드 활성화 여부 반환
 * @returns verbose 모드 활성화 여부
 *
 * Generated by Copilot
 */
public static isVerbose(): boolean {
  return Logger._config.verbose;
}

/**
 * debug 모드 활성화 여부 반환
 * @returns debug 모드 활성화 여부
 *
 * Generated by Copilot
 */
public static isDebug(): boolean {
  return Logger._config.debug;
}
```

#### 4. ESLint 규칙 추가 (선택사항)

직접적인 콘솔 사용을 제한하기 위한 ESLint 규칙을 추가합니다:

```json
// .eslintrc.json
{
  "rules": {
    "no-console": ["warn", { "allow": ["warn"] }]
  }
}
```

#### 5. 마이그레이션 전략

점진적으로 직접적인 `console.log` 호출을 대체하세요:

1. 중요도가 높은 모듈부터 시작
2. 새로운 코드에서는 반드시 `Logger` 또는 래퍼 함수 사용
3. 리팩토링 프로세스를 진행하며 기존 코드 업데이트

## 문제 해결

로깅 옵션이 예상대로 작동하지 않는 경우:

1. 현재 로깅 설정 확인:
   - `debug` 옵션은 `graphState` 설정도 함께 활성화합니다.
   - `verbose` 옵션은 기본 진행 로그만 활성화하며 상세 디버그 정보는 포함하지 않습니다.

2. 노드 스트리밍 가시성 우선순위:
   - 노드별 개별 설정 (`nodeStreamConfig`) > 항상 표시 노드 목록 > 전역 AI 스트림 설정 / 디버그 모드

3. 스트리밍 출력이 표시되지 않는 경우:
   - 해당 노드가 `--hide-stream-nodes`에 포함되어 있지 않은지 확인
   - 노드 이름이 정확한지 확인
   - 전역 AI 스트림 옵션(`--ai-stream`) 또는 디버그 모드(`--debug`) 활성화 시도

## 내부 구현 참고

`Logger` 클래스의 핵심 설정 메서드:

```typescript
public static configure(config: LoggerConfig): void {
  // 기존 설정 유지하면서 새 설정으로 업데이트
  Logger._config = {
    ...Logger._config,
    ...config,
    // nodeStreamConfig가 제공된 경우 병합
    nodeStreamConfig: {
      ...Logger._config.nodeStreamConfig,
      ...(config.nodeStreamConfig || {})
    },
    // alwaysVisibleNodes가 제공된 경우 덮어쓰기 아니면 기존 값 유지
    alwaysVisibleNodes: config.alwaysVisibleNodes || Logger._config.alwaysVisibleNodes
  };
}
```

스트리밍 가시성 결정 메서드:

```typescript
private static _isStreamingVisibleForNode(nodeName: string): boolean {
  // 1. 노드별 개별 설정이 있는 경우 우선 적용
  if (nodeName in Logger._config.nodeStreamConfig) {
    return Logger._config.nodeStreamConfig[nodeName];
  }
  // 2. 항상 표시해야 하는 노드 목록에 있는 경우
  if (Logger._config.alwaysVisibleNodes.includes(nodeName)) {
    return true;
  }
  // 3. 그 외에는 글로벌 AI 스트림 설정이나 디버그 모드에 따라 결정
  return Boolean(Logger._config.aiStream || Logger._config.debug);
}