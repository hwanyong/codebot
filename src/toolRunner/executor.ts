/**
 * 도구를 직접 실행하는 ToolExecutor 클래스
 * ToolExecutor class for direct tool execution
 *
 * Generated by Copilot
 */

import { BaseTool } from '../tools/base.js';
import { ToolPrompter } from './prompter.js';
import { ResultRenderer } from './renderer.js';
import { I18n } from '../config/i18n.js';
import { getAllTools } from '../tools/toolRegistry.js';

/**
 * 실행 히스토리 항목 인터페이스
 */
export interface ExecutionHistoryItem {
  timestamp: number;
  category: string;
  tool: string;
  parameters: Record<string, any>;
  result: ToolExecutionResult;
}

/**
 * 도구 실행 결과 인터페이스
 */
export interface ToolExecutionResult {
  success: boolean;
  data: any;
  error?: Error;
  duration: number;
}

/**
 * 도구를 직접 실행하는 클래스
 */
export class ToolExecutor {
  private _toolsMap: Map<string, Map<string, BaseTool>> = new Map();
  private _prompter: ToolPrompter;
  private _renderer: ResultRenderer;
  private _i18n: I18n;
  private _executionHistory: ExecutionHistoryItem[] = [];

  /**
   * ToolExecutor 클래스 생성자
   * @param prompter 사용자 프롬프트 처리기
   * @param renderer 결과 렌더러
   */
  constructor(prompter: ToolPrompter, renderer: ResultRenderer) {
    this._prompter = prompter;
    this._renderer = renderer;
    this._i18n = I18n.getInstance();
    this._initializeTools();
  }

  /**
   * 도구 초기화
   * @private
   */
  private _initializeTools(): void {
    const tools = getAllTools();

    // 도구를 카테고리별로 분류
    for (const tool of tools) {
      if (!this._toolsMap.has(tool.category)) {
        this._toolsMap.set(tool.category, new Map());
      }

      const categoryMap = this._toolsMap.get(tool.category);
      if (categoryMap) {
        categoryMap.set(tool.name, tool);
      }
    }
  }

  /**
   * 사용 가능한 카테고리 목록을 가져옵니다.
   * @returns 카테고리 목록
   */
  public getCategories(): string[] {
    return Array.from(this._toolsMap.keys());
  }

  /**
   * 특정 카테고리의 도구 목록을 가져옵니다.
   * @param category 카테고리 이름
   * @returns 도구 목록 또는 undefined (카테고리가 존재하지 않는 경우)
   */
  public getToolsByCategory(category: string): BaseTool[] | undefined {
    const categoryMap = this._toolsMap.get(category);
    if (!categoryMap) {
      return undefined;
    }

    return Array.from(categoryMap.values());
  }

  /**
   * 카테고리와 이름으로 도구를 가져옵니다.
   * @param category 카테고리 이름
   * @param name 도구 이름
   * @returns 도구 인스턴스 또는 undefined (도구가 존재하지 않는 경우)
   */
  public getToolByName(category: string, name: string): BaseTool | undefined {
    const categoryMap = this._toolsMap.get(category);
    if (!categoryMap) {
      return undefined;
    }

    return categoryMap.get(name);
  }

  /**
   * 도구를 실행합니다.
   * @param category 카테고리 이름
   * @param name 도구 이름
   * @param parameters 도구 매개변수
   * @returns 실행 결과
   */
  public async executeTool(
    category: string,
    name: string,
    parameters: Record<string, any> = {}
  ): Promise<ToolExecutionResult> {
    const tool = this.getToolByName(category, name);

    if (!tool) {
      throw new Error(this._i18n.t('tool_not_found', name, category));
    }

    const startTime = Date.now();
    let success = false;
    let result: any;
    let error: Error | undefined;

    try {
      // 도구 실행
      result = await tool.execute(parameters);
      success = true;
    } catch (err) {
      // 오류 처리
      error = err instanceof Error ? err : new Error(String(err));
      success = false;
      result = null;
    }

    const endTime = Date.now();
    const duration = endTime - startTime;

    const executionResult: ToolExecutionResult = {
      success,
      data: result,
      error,
      duration
    };

    // 실행 히스토리에 추가
    this._addToHistory(category, name, parameters, executionResult);

    return executionResult;
  }

  /**
   * 실행 히스토리에 결과 추가
   * @param category 카테고리 이름
   * @param name 도구 이름
   * @param parameters 매개변수
   * @param result 실행 결과
   * @private
   */
  private _addToHistory(
    category: string,
    name: string,
    parameters: Record<string, any>,
    result: ToolExecutionResult
  ): void {
    const historyItem: ExecutionHistoryItem = {
      timestamp: Date.now(),
      category,
      tool: name,
      parameters,
      result
    };

    this._executionHistory.push(historyItem);

    // 히스토리 크기 제한 (최근 100개 항목만 유지)
    if (this._executionHistory.length > 100) {
      this._executionHistory.shift();
    }
  }

  /**
   * 실행 히스토리를 가져옵니다.
   * @returns 실행 히스토리 배열
   */
  public getExecutionHistory(): ExecutionHistoryItem[] {
    return [...this._executionHistory];
  }

  /**
   * 결과 렌더러를 반환합니다.
   * @returns 결과 렌더러 인스턴스
   */
  public getRenderer(): ResultRenderer {
    return this._renderer;
  }

  /**
   * 대화형으로 도구를 실행합니다.
   */
  public async runInteractive(): Promise<void> {
    let continueExecution = true;

    try {
      while (continueExecution) {
        // 카테고리 선택
        const categories = this.getCategories();
        const selectedCategory = await this._prompter.selectCategory(categories);

        // 카테고리의 도구 목록 가져오기
        const tools = this.getToolsByCategory(selectedCategory);

        if (!tools || tools.length === 0) {
          throw new Error(this._i18n.t('no_tools_available'));
        }

        let continueWithSameTool = true;
        let selectedTool: BaseTool | null = null;

        while (continueWithSameTool) {
          // 이전에 선택한 도구가 없는 경우에만 도구 선택
          if (!selectedTool) {
            selectedTool = await this._prompter.selectTool(tools);
          }

          // 매개변수 입력
          const parameters = await this._prompter.getParameters(selectedTool);

          // 도구 실행
          const result = await this.executeTool(selectedTool.category, selectedTool.name, parameters);

          // 결과 표시
          this._renderer.renderResult(selectedTool, parameters, result);

          // 같은 도구로 계속할지 확인
          continueWithSameTool = await this._prompter.askToUseSameTool();

          // 다른 도구 선택 시 현재 선택된 도구 초기화
          if (!continueWithSameTool) {
            selectedTool = null;
          }
        }

        // 계속 실행할지 확인
        continueExecution = await this._prompter.askToRunAgain();
      }
    } finally {
      // 리소스 정리
      this._prompter.close();
    }
  }
}