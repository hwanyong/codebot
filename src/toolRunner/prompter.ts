/**
 * 도구 실행을 위한 사용자 프롬프트 처리 클래스
 * User prompt handler for tool execution
 *
 * Generated by Copilot
 */

import readline from 'readline/promises';
import chalk from 'chalk';
import { BaseTool } from '../tools/base.js';
import { I18n } from '../config/i18n.js';
import { z } from 'zod';

/**
 * 도구 실행을 위한 사용자 입력 처리 클래스
 */
export class ToolPrompter {
  private _rl: readline.Interface;
  private _i18n: I18n;

  /**
   * ToolPrompter 클래스 생성자
   */
  constructor() {
    this._rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    this._i18n = I18n.getInstance();
  }

  /**
   * 사용자에게 카테고리 선택을 요청합니다.
   * @param categories 사용 가능한 카테고리 목록
   * @returns 선택된 카테고리
   */
  public async selectCategory(categories: string[]): Promise<string> {
    if (categories.length === 0) {
      throw new Error(this._i18n.t('no_categories_available'));
    }

    console.log(chalk.cyan(this._i18n.t('select_category')));

    for (let i = 0; i < categories.length; i++) {
      console.log(`${i + 1}. ${categories[i]}`);
    }

    while (true) {
      const answer = await this._rl.question(chalk.green(`${this._i18n.t('enter_number')} (1-${categories.length}): `));
      const index = parseInt(answer, 10) - 1;

      if (!isNaN(index) && index >= 0 && index < categories.length) {
        return categories[index];
      }

      console.log(chalk.red(this._i18n.t('invalid_selection')));
    }
  }

  /**
   * 사용자에게 도구 선택을 요청합니다.
   * @param tools 사용 가능한 도구 목록
   * @returns 선택된 도구
   */
  public async selectTool(tools: BaseTool[]): Promise<BaseTool> {
    if (tools.length === 0) {
      throw new Error(this._i18n.t('no_tools_available'));
    }

    console.log(chalk.cyan(this._i18n.t('select_tool')));

    for (let i = 0; i < tools.length; i++) {
      console.log(`${i + 1}. ${tools[i].name} - ${tools[i].description}`);
    }

    while (true) {
      const answer = await this._rl.question(chalk.green(`${this._i18n.t('enter_number')} (1-${tools.length}): `));
      const index = parseInt(answer, 10) - 1;

      if (!isNaN(index) && index >= 0 && index < tools.length) {
        return tools[index];
      }

      console.log(chalk.red(this._i18n.t('invalid_selection')));
    }
  }

  /**
   * 사용자에게 도구 실행을 위한 파라미터를 입력받습니다.
   * @param tool 파라미터를 입력받을 도구
   * @returns 입력된 파라미터 객체
   */
  public async getParameters(tool: BaseTool): Promise<Record<string, any>> {
    console.log(chalk.cyan(this._i18n.t('enter_parameters', tool.name)));
    console.log(chalk.yellow(this._i18n.t('parameters_info')));

    // 입력 방식 선택
    const inputMethod = await this._selectInputMethod();

    if (inputMethod === 'json') {
      return await this._getParametersAsJson();
    } else {
      return await this._getParametersInteractively(tool);
    }
  }

  /**
   * 파라미터 입력 방식을 선택합니다.
   * @private
   * @returns 선택된 입력 방식
   */
  private async _selectInputMethod(): Promise<'interactive' | 'json'> {
    console.log(chalk.cyan(this._i18n.t('select_input_method')));
    console.log(`1. ${this._i18n.t('interactive_input')}`);
    console.log(`2. ${this._i18n.t('json_input')}`);

    while (true) {
      const answer = await this._rl.question(chalk.green(`${this._i18n.t('enter_number')} (1-2): `));

      if (answer === '1') {
        return 'interactive';
      } else if (answer === '2') {
        return 'json';
      }

      console.log(chalk.red(this._i18n.t('invalid_selection')));
    }
  }

  /**
   * JSON 형식으로 파라미터를 입력받습니다.
   * @private
   * @returns 입력된 파라미터 객체
   */
  private async _getParametersAsJson(): Promise<Record<string, any>> {
    console.log(chalk.yellow(this._i18n.t('enter_json_parameters')));

    while (true) {
      try {
        const jsonInput = await this._rl.question(chalk.green(`${this._i18n.t('json_prompt')}\n`));

        if (!jsonInput.trim()) {
          return {}; // 빈 객체 반환
        }

        const parameters = JSON.parse(jsonInput);

        if (typeof parameters !== 'object' || parameters === null) {
          throw new Error(this._i18n.t('invalid_json_object'));
        }

        return parameters;
      } catch (error) {
        console.log(chalk.red(this._i18n.t('json_parse_error', error instanceof Error ? error.message : String(error))));
        const retry = await this._askYesNo(this._i18n.t('try_again'));

        if (!retry) {
          return {}; // 빈 객체 반환
        }
      }
    }
  }

  /**
   * 대화형으로 파라미터를 입력받습니다.
   * @private
   * @param tool 파라미터를 입력받을 도구
   * @returns 입력된 파라미터 객체
   */
  private async _getParametersInteractively(tool: BaseTool): Promise<Record<string, any>> {
    const parameters: Record<string, any> = {};

    // 도구에 매개변수 스키마가 없는 경우 빈 객체 반환
    if (!tool.parameterSchema) {
      console.log(chalk.yellow(`${this._i18n.t('no_parameters_required')}`));
      return parameters;
    }

    // Zod 객체 스키마에서 안전하게 속성 추출
    const zodSchema = tool.parameterSchema as z.ZodObject<any>;
    const shape = zodSchema._def.shape();

    console.log(chalk.yellow(this._i18n.t('interactive_parameters')));

    // shape 객체를 통해 각 속성 처리
    for (const [name, untypedPropertySchema] of Object.entries(shape)) {
      // 타입 단언으로 속성 스키마에 접근할 수 있게 함
      const propertySchema = untypedPropertySchema as z.ZodTypeAny;

      // 속성의 메타데이터 안전하게 추출
      let description = name;
      let isOptional = false;

      // zod의 메타데이터 접근 (type-safe 방식)
      if (typeof propertySchema._def === 'object') {
        // description 추출 시도
        if ('description' in propertySchema._def && typeof propertySchema._def.description === 'string') {
          description = propertySchema._def.description;
        }

        // 선택적 필드 여부 확인
        isOptional = propertySchema.isOptional?.() || false;
      }

      // 타입 감지 (타입 안전하게)
      let type = 'string';
      if (typeof propertySchema.constructor?.name === 'string') {
        type = propertySchema.constructor.name;
      }

      console.log(
        chalk.cyan(`${name}`) +
        (!isOptional ? chalk.red(` (${this._i18n.t('required')})`) : chalk.gray(` (${this._i18n.t('optional')})`)) +
        `: ${description}`
      );

      let paramValue: any = undefined;
      let validInput = false;

      while (!validInput) {
        const input = await this._rl.question(chalk.green(`${name}: `));

        if (!input.trim() && isOptional) {
          validInput = true; // 선택적 파라미터는 빈 값 허용
          continue;
        }

        if (!input.trim() && !isOptional) {
          console.log(chalk.red(this._i18n.t('parameter_required', name)));
          continue;
        }

        try {
          // 타입에 따라 입력값 변환
          if (type.includes('Number')) {
            paramValue = parseFloat(input);
            if (isNaN(paramValue)) {
              throw new Error(this._i18n.t('invalid_number'));
            }
          } else if (type.includes('Boolean')) {
            if (['true', 'yes', 'y', '1'].includes(input.toLowerCase())) {
              paramValue = true;
            } else if (['false', 'no', 'n', '0'].includes(input.toLowerCase())) {
              paramValue = false;
            } else {
              throw new Error(this._i18n.t('invalid_boolean'));
            }
          } else if (type.includes('Array')) {
            try {
              paramValue = JSON.parse(input);
              if (!Array.isArray(paramValue)) {
                throw new Error(this._i18n.t('not_array'));
              }
            } catch (e) {
              // 쉼표로 구분된 값을 배열로 변환 시도
              paramValue = input.split(',').map(item => item.trim());
            }
          } else if (type.includes('Object')) {
            try {
              paramValue = JSON.parse(input);
              if (typeof paramValue !== 'object' || paramValue === null) {
                throw new Error(this._i18n.t('invalid_object'));
              }
            } catch (e) {
              throw new Error(this._i18n.t('invalid_json'));
            }
          } else {
            paramValue = input;
          }

          validInput = true;
        } catch (error) {
          console.log(chalk.red(this._i18n.t('invalid_input', error instanceof Error ? error.message : String(error))));
        }
      }

      if (paramValue !== undefined) {
        parameters[name] = paramValue;
      }
    }

    // 입력 확인
    console.log(chalk.yellow(this._i18n.t('parameters_summary')));
    console.log(JSON.stringify(parameters, null, 2));

    const confirmed = await this._askYesNo(this._i18n.t('confirm_parameters'));

    if (!confirmed) {
      return await this.getParameters(tool);
    }

    return parameters;
  }

  /**
   * 예/아니오 질문을 표시하고 응답을 받습니다.
   * @param question 표시할 질문
   * @returns 사용자 응답 (예: true, 아니오: false)
   * @private
   */
  private async _askYesNo(question: string): Promise<boolean> {
    while (true) {
      const answer = await this._rl.question(chalk.green(`${question} (y/n): `));

      if (['y', 'yes', 'true', '예', '네'].includes(answer.toLowerCase())) {
        return true;
      } else if (['n', 'no', 'false', '아니오', '아니요'].includes(answer.toLowerCase())) {
        return false;
      }

      console.log(chalk.red(this._i18n.t('invalid_yes_no')));
    }
  }

  /**
   * 도구를 다시 실행할지 묻습니다.
   * @returns 다시 실행 여부
   */
  public async askToRunAgain(): Promise<boolean> {
    return await this._askYesNo(this._i18n.t('run_again'));
  }

  /**
   * 같은 도구를 사용할지 묻습니다.
   * @returns 같은 도구 사용 여부
   */
  public async askToUseSameTool(): Promise<boolean> {
    return await this._askYesNo(this._i18n.t('use_same_tool'));
  }

  /**
   * 리소스를 정리합니다.
   */
  public close(): void {
    this._rl.close();
  }
}