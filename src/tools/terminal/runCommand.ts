/**
 * 터미널 명령어 실행 도구
 * Run Command Tool
 *
 * 시스템 터미널에서 명령어를 실행합니다.
 * Executes commands in the system terminal.
 *
 * Generated by Copilot
 */

import { BaseTool } from '../base.js';
import { z } from 'zod';
import { exec } from 'child_process';
import { promisify } from 'util';

// exec를 Promise로 변환
const execPromise = promisify(exec);

/**
 * 명령어 실행 결과 인터페이스
 */
export interface CommandResult {
  stdout: string;
  stderr: string;
  exitCode: number;
  command: string;
  success: boolean; // 명령어 실행 성공 여부
}

/**
 * 터미널 명령어 실행 도구
 */
export class RunCommandTool extends BaseTool<
  { command: string; workingDir?: string; env?: Record<string, string> },
  CommandResult
> {
  constructor() {
    super(
      'RunCommand',
      '터미널 명령어를 실행합니다.',
      'terminal',
      z.object({
        command: z.string().describe('실행할 명령어'),
        workingDir: z.string().optional().describe('작업 디렉토리 (선택적)'),
        env: z.record(z.string()).optional().describe('환경 변수 (선택적)')
      })
    );
  }

  /**
   * 명령어를 실행합니다.
   * @param params.command 실행할 명령어
   * @param params.workingDir 작업 디렉토리 (선택적)
   * @param params.env 환경 변수 (선택적)
   * @returns 명령어 실행 결과
   */
  protected async _execute(params: {
    command: string;
    workingDir?: string;
    env?: Record<string, string>;
  }): Promise<CommandResult> {
    try {
      const { command, workingDir, env } = params;

      // 명령어 실행 옵션 설정
      const options: {
        cwd?: string;
        env?: NodeJS.ProcessEnv;
      } = {};

      // 작업 디렉토리 설정
      if (workingDir) {
        options.cwd = workingDir;
      }

      // 환경 변수 설정
      if (env) {
        options.env = {
          ...process.env,
          ...env
        };
      }

      // 명령어 실행
      const { stdout, stderr } = await execPromise(command, options);

      // 결과 반환
      return {
        stdout: stdout.trim(),
        stderr: stderr.trim(),
        exitCode: 0, // 성공적인 실행을 나타내는 종료 코드
        command,
        success: true // 명령어가 성공적으로 실행됨
      };
    } catch (error: any) {
      // 명령어 실행 실패 처리
      if (error.stdout || error.stderr) {
        // exec의 오류에는 stdout과 stderr이 포함됨
        return {
          stdout: error.stdout ? error.stdout.trim() : '',
          stderr: error.stderr ? error.stderr.trim() : '',
          exitCode: error.code || 1, // 오류 발생 시의 종료 코드
          command: params.command,
          success: false // 명령어 실행 실패
        };
      }

      // 기타 오류 처리
      throw new Error(`명령어 실행 실패: ${error.message || String(error)}`);
    }
  }
}