import { z } from 'zod';
import { Tool } from '../../types/index.js';
import { I18n, Language } from '../../config/i18n.js';
import { ConfigManager } from '../../config/manager.js';

// Generated by Copilot
/**
 * Custom error class for translation-specific errors
 * 번역 관련 오류를 위한 사용자 정의 오류 클래스
 */
export class TranslationError extends Error {
  constructor(message: string, public readonly code: string) {
    super(message);
    this.name = 'TranslationError';
  }
}

/**
 * Translate text tool input schema
 * 텍스트 번역 도구 입력 스키마
 */
export const translateTextSchema = z.object({
  text: z.string().min(1, { message: 'Text is required. (텍스트는 필수입니다.)' }),
  targetLanguage: z.enum(['en', 'ko']).optional(), // Make it optional since we'll determine it from config
  sourceLanguage: z.enum(['en', 'ko', 'auto']).default('auto'),
  provider: z.string().optional(),
  model: z.string().optional()
});

/**
 * Supported language codes
 * 지원되는 언어 코드
 */
export type SupportedLanguage = 'en' | 'ko';

/**
 * Translation result interface
 * 번역 결과 인터페이스
 */
interface TranslationResult {
  success: boolean;
  sourceLanguage: string;
  targetLanguage: string;
  originalText: string;
  translatedText: string;
  message: string;
  provider?: string | null;
  model?: string | null;
  error?: string;
}

/**
 * Translate text tool
 * 텍스트 번역 도구
 * Translates text between supported languages using AI providers
 * AI 제공자를 사용하여 지원되는 언어 간에 텍스트를 번역합니다
 */
export class TranslateTextTool implements Tool {
  name = 'translate_text';
  description = 'Translates text between supported languages (English and Korean) using AI providers. (AI 제공자를 사용하여 지원되는 언어(영어 및 한국어) 간에 텍스트를 번역합니다.)';
  schema = translateTextSchema;

  // _i18n instance for translations
  private _i18n = I18n.getInstance();

  // _configManager for provider configuration
  private _configManager = new ConfigManager();

  // Fallback translation mapping for basic words when AI provider is not available
  // AI 제공자를 사용할 수 없을 때 기본 단어에 대한 대체 번역 매핑
  private _fallbackTranslationMap: {
    [key: string]: { en: string, ko: string }
  } = {
    'hello': { en: 'hello', ko: '안녕하세요' },
    'world': { en: 'world', ko: '세계' },
    'file': { en: 'file', ko: '파일' },
    'folder': { en: 'folder', ko: '폴더' },
    'directory': { en: 'directory', ko: '디렉토리' },
    'create': { en: 'create', ko: '생성' },
    'read': { en: 'read', ko: '읽기' },
    'write': { en: 'write', ko: '쓰기' },
    'update': { en: 'update', ko: '업데이트' },
    'delete': { en: 'delete', ko: '삭제' },
    'search': { en: 'search', ko: '검색' },
    'error': { en: 'error', ko: '오류' },
    'success': { en: 'success', ko: '성공' },
    'command': { en: 'command', ko: '명령어' },
    'language': { en: 'language', ko: '언어' },
    'code': { en: 'code', ko: '코드' },
    'analysis': { en: 'analysis', ko: '분석' },
    'translation': { en: 'translation', ko: '번역' },
    'hi': { en: 'hi', ko: '안녕' }
  };

  /**
   * Get language name for logging
   * 로깅을 위한 언어 이름 가져오기
   * @param langCode Language code (언어 코드)
   * @returns Language name (언어 이름)
   */
  private getLanguageName(langCode: string): string {
    return langCode === 'ko' ? this._i18n.t('korean') : this._i18n.t('english');
  }

  /**
   * Creates a translation prompt for AI provider
   * AI 제공자를 위한 번역 프롬프트 생성
   * @param text Text to translate (번역할 텍스트)
   * @param sourceLang Source language (원본 언어)
   * @param targetLang Target language (대상 언어)
   * @returns Prompt for AI 제공자를 위한 프롬프트)
   */
  private createTranslationPrompt(text: string, sourceLang: string, targetLang: string): string {
    const sourceLangName = this.getLanguageName(sourceLang);
    const targetLangName = this.getLanguageName(targetLang);

    return `You are a professional translator specializing in ${sourceLangName} to ${targetLangName} translation.
Translate the following text from ${sourceLangName} to ${targetLangName}.
Provide only the translation without explanations, quotes, or comments.

Text to translate:
---
${text}
---

Translation:`;
  }

  /**
   * Detects language of the text
   * 텍스트의 언어를 감지합니다
   * @param text Text to detect language (언어를 감지할 텍스트)
   * @returns Detected language code (감지된 언어 코드)
   */
  private detectLanguage(text: string): Language {
    // More robust detection for Korean characters
    // 한글 문자에 대한 더 강력한 감지
    const koreanPattern = /[ㄱ-ㅎㅏ-ㅣ가-힣]/;

    // Remove quotes and other non-relevant characters for detection
    const cleanText = text.replace(/['",.!?()[\]{}]/g, "").trim();

    // Log detection information for debugging
    console.log(`Language detection for: "${cleanText}"`);
    console.log(`Contains Korean characters: ${koreanPattern.test(cleanText)}`);

    // If any Korean character is found, consider it Korean
    if (koreanPattern.test(cleanText)) {
      console.log("Language detected: Korean (ko)");
      return 'ko';
    }

    console.log("Language detected: English (en)");
    return 'en';
  }

  /**
   * Translate using fallback mechanism when AI provider is not available
   * AI 제공자를 사용할 수 없을 때 대체 메커니즘을 사용하여 번역
   * @param text Text to translate (번역할 텍스트)
   * @param sourceLanguage Source language (원본 언어)
   * @param targetLanguage Target language (대상 언어)
   * @returns Translated text (번역된 텍스트)
   */
  private fallbackTranslate(text: string, sourceLanguage: Language, targetLanguage: Language): string {
    // If source and target are the same, return the original text
    if (sourceLanguage === targetLanguage) {
      return text;
    }

    // Simple word replacement translation
    // 간단한 단어 교체 번역
    const words = text.split(' ');
    const translatedWords = words.map(word => {
      // Remove punctuation for lookup
      const cleanWord = word.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "");

      if (this._fallbackTranslationMap[cleanWord]) {
        const translation = this._fallbackTranslationMap[cleanWord][targetLanguage];
        // Replace the clean word with translation but keep the punctuation
        return word.replace(cleanWord, translation);
      }
      return word;
    });

    return translatedWords.join(' ');
  }

  /**
   * Translates text using an OpenAI provider
   * OpenAI 제공자를 사용하여 텍스트 번역
   */
  private async translateWithOpenAI(
    provider: any,
    model: string,
    prompt: string
  ): Promise<string> {
    try {
      const { OpenAI } = await import('openai');
      const apiClient = new OpenAI({
        apiKey: provider.apiKey,
        baseURL: provider.baseUrl
      });

      const response = await apiClient.chat.completions.create({
        model: model || 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3,
      });

      if (!response.choices[0]?.message?.content) {
        throw new TranslationError('Empty response from OpenAI', 'EMPTY_RESPONSE');
      }

      return response.choices[0].message.content.trim();
    } catch (error: any) {
      throw new TranslationError(
        `OpenAI translation failed: ${error.message}`,
        'OPENAI_API_ERROR'
      );
    }
  }

  /**
   * Translates text using an Anthropic provider
   * Anthropic 제공자를 사용하여 텍스트 번역
   */
  private async translateWithAnthropic(
    provider: any,
    model: string,
    prompt: string
  ): Promise<string> {
    try {
      const { Anthropic } = await import('@anthropic-ai/sdk');
      const apiClient = new Anthropic({
        apiKey: provider.apiKey,
        baseURL: provider.baseUrl
      });

      const response = await apiClient.messages.create({
        model: model || 'claude-3-sonnet-20240229',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3,
        max_tokens: 1000
      });

      if (!response.content || response.content[0]?.type !== 'text') {
        throw new TranslationError('Invalid response format from Anthropic', 'INVALID_RESPONSE');
      }

      return response.content[0].text?.trim() || '';
    } catch (error: any) {
      throw new TranslationError(
        `Anthropic translation failed: ${error.message}`,
        'ANTHROPIC_API_ERROR'
      );
    }
  }

  /**
   * Translates text using an Ollama provider
   * Ollama 제공자를 사용하여 텍스트 번역
   */
  private async translateWithOllama(
    provider: any,
    model: string,
    prompt: string
  ): Promise<string> {
    try {
      const baseUrl = provider.baseUrl || 'http://localhost:11434';
      const response = await fetch(`${baseUrl}/api/generate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: model || 'llama3',
          prompt: prompt,
          temperature: 0.3,
          stop: ['\n\n'], // Allow more natural responses
        }),
      });

      if (!response.ok) {
        throw new TranslationError(
          `Ollama API error: ${response.status} ${response.statusText}`,
          'OLLAMA_API_ERROR'
        );
      }

      const data = await response.json();

      if (!data.response) {
        throw new TranslationError('Empty response from Ollama', 'EMPTY_RESPONSE');
      }

      return data.response.trim();
    } catch (error: any) {
      throw new TranslationError(
        `Ollama translation failed: ${error.message}`,
        'OLLAMA_API_ERROR'
      );
    }
  }

  /**
   * Translates text using a custom provider
   * 사용자 정의 제공자를 사용하여 텍스트 번역
   */
  private async translateWithCustomProvider(
    provider: any,
    model: string,
    prompt: string
  ): Promise<string> {
    try {
      const params: any = {
        messages: [{ role: 'user', content: prompt }],
        model: model,
      };

      const response = await fetch(provider.baseUrl || '', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${provider.apiKey}`
        },
        body: JSON.stringify(params),
      });

      if (!response.ok) {
        throw new TranslationError(
          `Custom API error: ${response.status} ${response.statusText}`,
          'CUSTOM_API_ERROR'
        );
      }

      const customData = await response.json();

      if (!customData?.choices?.[0]?.message?.content) {
        throw new TranslationError('Invalid response format from provider', 'INVALID_RESPONSE');
      }

      return customData.choices[0].message.content.trim();
    } catch (error: any) {
      throw new TranslationError(
        `Custom provider translation failed: ${error.message}`,
        'CUSTOM_API_ERROR'
      );
    }
  }

  /**
   * Translates text using an AI provider
   * AI 제공자를 사용하여 텍스트 번역
   */
  private async translateWithProvider(
    text: string,
    sourceLanguage: Language,
    targetLanguage: Language,
    providerId?: string,
    modelId?: string
  ): Promise<{translatedText: string, provider: string, model: string}> {
    // Get provider from input or use the default
    const provider = providerId
      ? this._configManager.getProviderByName(providerId)
      : this._configManager.getDefaultProvider();

    if (!provider) {
      throw new TranslationError('No translation provider available', 'NO_PROVIDER');
    }

    if (!provider.apiKey && provider.type !== 'ollama') {
      throw new TranslationError('Provider has no API key configured', 'NO_API_KEY');
    }

    // Select model for translation
    const model = modelId || (provider.models && provider.models.length > 0
      ? provider.models[0]
      : undefined);

    // Create translation prompt
    const translationPrompt = this.createTranslationPrompt(
      text,
      sourceLanguage,
      targetLanguage
    );

    // Perform translation based on provider type
    let translatedText: string;

    switch (provider.type) {
      case 'openai':
        translatedText = await this.translateWithOpenAI(provider, model!, translationPrompt);
        break;

      case 'anthropic':
        translatedText = await this.translateWithAnthropic(provider, model!, translationPrompt);
        break;

      case 'ollama':
        translatedText = await this.translateWithOllama(provider, model!, translationPrompt);
        break;

      default:
        translatedText = await this.translateWithCustomProvider(provider, model!, translationPrompt);
    }

    // Clean up the response by removing quotes if present
    translatedText = translatedText.replace(/^['"](.*)['"]$/g, '$1');

    return {
      translatedText,
      provider: provider.name,
      model: model || 'default'
    };
  }

  /**
   * Main translation function
   * 주요 번역 함수
   */
  private async performTranslation(
    text: string,
    targetLanguage: Language | undefined,
    sourceLanguage: Language | 'auto',
    providerId?: string,
    modelId?: string
  ): Promise<TranslationResult> {
    // Get the system configured language
    const configLanguage = this._configManager.getLanguage();

    // Determine target language - always English if not explicitly set
    const actualTargetLanguage: Language = targetLanguage || 'en';

    // Determine the actual source language
    // If sourceLanguage is 'auto', detect it; otherwise, use what's provided
    // If sourceLanguage is not provided, use the configured system language
    const actualSource = sourceLanguage === 'auto'
      ? this.detectLanguage(text)
      : (sourceLanguage || configLanguage);

    // Log the language configuration and detection results
    console.log(`Config language: ${configLanguage}, Input source: ${sourceLanguage}, Detected source: ${actualSource}, Target: ${actualTargetLanguage}`);
    console.log(`Translation request: "${text}"`);

    // Return early if text is already in target language
    if (actualSource === actualTargetLanguage) {
      console.log(`Early return: Text already in ${actualTargetLanguage} language`);
      return {
        success: true,
        sourceLanguage: actualSource,
        targetLanguage: actualTargetLanguage,
        originalText: text,
        translatedText: text,
        message: this._i18n.t('already_target_language')
      };
    }

    try {
      // Try to translate using AI provider
      const { translatedText, provider, model } = await this.translateWithProvider(
        text,
        actualSource,
        actualTargetLanguage,
        providerId,
        modelId
      );

      // Verify we actually got a translation and not the original text
      if (translatedText.trim().toLowerCase() === text.trim().toLowerCase()) {
        // If API returned the same text, use fallback
        console.log('API returned original text, using fallback translation');
        const fallbackText = this.fallbackTranslate(text, actualSource, actualTargetLanguage);

        return {
          success: true,
          sourceLanguage: actualSource,
          targetLanguage: actualTargetLanguage,
          originalText: text,
          translatedText: fallbackText,
          message: this._i18n.t('translation_fallback_used'),
          provider,
          model
        };
      }

      return {
        success: true,
        sourceLanguage: actualSource,
        targetLanguage: actualTargetLanguage,
        originalText: text,
        translatedText,
        message: this._i18n.t('translation_completed'),
        provider,
        model
      };
    } catch (error) {
      // Log the specific error for debugging
      console.error('AI translation error:', error);

      // Fallback to basic translation
      const fallbackText = this.fallbackTranslate(text, actualSource, actualTargetLanguage);

      return {
        success: true,
        sourceLanguage: actualSource,
        targetLanguage: actualTargetLanguage,
        originalText: text,
        translatedText: fallbackText,
        message: this._i18n.t('translation_fallback_used'),
        error: error instanceof TranslationError ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Translates text between supported languages
   * 지원되는 언어 간에 텍스트를 번역합니다
   * @param input Tool input data (도구 입력 데이터)
   * @returns Translation result (번역 결과)
   */
  async execute(input: z.infer<typeof translateTextSchema> | any): Promise<TranslationResult> {
    try {
      // Handle different parameter naming conventions from various tool callers
      // text can be input.text or input.text_to_translate
      // sourceLanguage can be input.sourceLanguage or input.source_language
      // targetLanguage can be input.targetLanguage or input.target_language
      const text = input.text || input.text_to_translate || '';
      const sourceLanguage = input.sourceLanguage || input.source_language || 'auto';
      const targetLanguage = input.targetLanguage || input.target_language;
      const provider = input.provider || input.translation_provider;
      const model = input.model || input.translation_model;

      // Validate required inputs
      if (!text || typeof text !== 'string') {
        return {
          success: false,
          sourceLanguage,
          targetLanguage: targetLanguage || 'en',
          originalText: text || '',
          translatedText: text || '',
          error: 'Missing or invalid text input',
          message: this._i18n.t('translation_failed', 'Missing or invalid text input')
        };
      }

      // Remove quotes if they're wrapping the entire text (common when passing from other tools)
      const cleanText = text.replace(/^(['"])(.*)\1$/, '$2');

      console.log(`Execute translation with params: text="${cleanText}", source=${sourceLanguage}, target=${targetLanguage || 'en (default)'}`);

      return await this.performTranslation(
        cleanText,
        targetLanguage,
        sourceLanguage as Language | 'auto',
        provider,
        model
      );
    } catch (error: any) {
      // Only catch truly unexpected errors that weren't handled in performTranslation
      console.error('Unexpected translation error:', error);

      return {
        success: false,
        sourceLanguage: input.sourceLanguage || input.source_language || 'auto',
        targetLanguage: input.targetLanguage || input.target_language || 'en',
        originalText: input.text || input.text_to_translate || '',
        translatedText: input.text || input.text_to_translate || '',
        error: error.message,
        message: this._i18n.t('translation_failed', error.message)
      };
    }
  }
}