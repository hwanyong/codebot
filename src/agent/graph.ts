import { StateGraph } from '@langchain/langgraph';
import { RunnableConfig } from '@langchain/core/runnables';
import { StateAnnotation, State } from './state.js';
import {
  nodeTranslateInput,
  nodeAnalyzeTask,
  nodePlanExecution,
  nodeExecuteStep,
  nodeVerifyResult,
  nodeGenerateResponse,
  nodeHandleError
} from './nodes/index.js';
import { Logger } from '../utils/logger.js';

/**
 * Routing function
 * 라우팅 함수
 * Determines the next node based on the current state
 * 현재 상태에 따라 다음 노드를 결정합니다.
 * @param state Current state (현재 상태)
 * @returns Next node name (다음 노드 이름)
 *
 * Generated by Copilot
 */
function routeNode(state: State): string {
  // If in error state, go to error handling node
  // 오류 상태인 경우 오류 처리 노드로 이동
  if (state.context.executionStatus === 'error') {
    Logger.graphState('Router Decision', 'Route to handleError due to error state');
    return 'handleError';
  }

  // If marked as direct response, skip execution and go straight to response generation
  // 직접 응답으로 표시된 경우 실행을 건너뛰고 응답 생성으로 바로 이동
  if (state.context.directResponse === true) {
    Logger.graphState('Router Decision', 'Direct response case - route to generateResponse');
    return 'generateResponse';
  }

  // If execution plan exists and current step remains, go to step execution node
  // 실행 계획이 있고 현재 단계가 남아있는 경우 단계 실행 노드로 이동
  if (
    state.context.executionPlan &&
    state.context.currentStepIndex !== undefined &&
    state.context.totalSteps !== undefined &&
    state.context.currentStepIndex < state.context.totalSteps
  ) {
    Logger.graphState('Router Decision', `Route to executeStep (${state.context.currentStepIndex}/${state.context.totalSteps})`);
    return 'executeStep';
  }

  // If execution is completed but verification is needed, go to verification node
  // 실행이 완료되었지만 검증이 필요한 경우 검증 노드로 이동
  if (
    state.context.executionStatus === 'completed' &&
    state.context.verified === undefined &&
    state.context.requiresToolExecution !== false
  ) {
    Logger.graphState('Router Decision', 'Route to verifyResult for verification');
    return 'verifyResult';
  }

  // If verification is completed, go to response generation node
  // 검증이 완료된 경우 응답 생성 노드로 이동
  if (state.context.verified !== undefined) {
    Logger.graphState('Router Decision', 'Route to generateResponse after verification');
    return 'generateResponse';
  }

  // Default to response generation node
  // 기본적으로 응답 생성 노드로 이동
  Logger.graphState('Router Decision', 'Default route to generateResponse');
  return 'generateResponse';
}

/**
 * Graph builder
 * 그래프 빌더
 * Configures the LangGraph state graph
 * LangGraph 상태 그래프를 구성합니다.
 */
const builder = new StateGraph(StateAnnotation);

// Add nodes
// 노드 추가
builder
  .addNode('translateInput', nodeTranslateInput)
  .addNode('analyzeTask', nodeAnalyzeTask)
  .addNode('planExecution', nodePlanExecution)
  .addNode('executeStep', nodeExecuteStep)
  .addNode('verifyResult', nodeVerifyResult)
  .addNode('generateResponse', nodeGenerateResponse)
  .addNode('handleError', nodeHandleError);

// Add edges - using type assertion while maintaining method chaining
// 엣지 추가 - 타입 단언 사용하되 메서드 체이닝 유지
builder
  .addEdge("__start__" as any, "translateInput" as any)
  .addEdge("translateInput" as any, "analyzeTask" as any)
  .addEdge("analyzeTask" as any, "planExecution" as any)
  .addConditionalEdges("planExecution" as any, routeNode)
  .addConditionalEdges("executeStep" as any, routeNode)
  .addConditionalEdges("verifyResult" as any, routeNode)
  .addEdge("handleError" as any, "generateResponse" as any)
  .addEdge("generateResponse" as any, "__end__" as any);

// Compile graph
// 그래프 컴파일
export const codebotGraph = builder.compile();

/**
 * Creates a properly formatted error object for the context state
 * 컨텍스트 상태에 맞게 적절히 포맷된 오류 객체를 생성합니다
 *
 * @param error - The error to format
 * @returns A formatted error object conforming to ContextState.lastError type
 */
function formatErrorForContext(error: unknown): {
  message: string;
  timestamp: string;
  type: string;
  stack?: string;
} {
  const timestamp = new Date().toISOString();

  if (error instanceof Error) {
    return {
      message: error.message,
      timestamp,
      type: error.name || 'Error',
      stack: error.stack
    };
  }

  return {
    message: String(error),
    timestamp,
    type: 'UnknownError'
  };
}

/**
 * Enhanced invoke method with safe debugging support
 * 디버깅을 안전하게 지원하는 향상된 invoke 메소드
 *
 * @param state Current state (현재 상태)
 * @param config Configuration options (설정 옵션)
 * @returns Updated state (업데이트된 상태)
 */
const safeInvoke = async (state: State, config?: RunnableConfig): Promise<State> => {
  // Early validation to prevent null/undefined errors
  // null/undefined 오류를 방지하기 위한 초기 유효성 검사
  if (!state) {
    Logger.error('Invalid state provided to graph invoke');
    throw new Error('Invalid state provided to graph invoke');
  }

  try {
    Logger.graphState('Graph Execution Started', {
      executionStatus: state.context?.executionStatus || 'unknown',
      messageCount: state.messages?.length || 0
    });

    // Use the original invoke method directly to avoid Symbol issues in debug mode
    // 디버그 모드에서 Symbol 문제를 피하기 위해 원본 invoke 메소드를 직접 사용
    const result = await (codebotGraph as any).wrapped_invoke?.(state, config) ||
                   await (codebotGraph as any)._invoke?.(state, config) ||
                   await (codebotGraph as any).invoke.original?.call(codebotGraph, state, config);

    if (!result) {
      Logger.error('Graph execution returned null or undefined result');
      throw new Error('Graph execution failed with null result');
    }

    Logger.graphState('Graph Execution Completed', {
      executionStatus: result.context?.executionStatus || 'unknown',
      messageCount: result.messages?.length || 0,
      currentStepIndex: result.context?.currentStepIndex,
      totalSteps: result.context?.totalSteps
    });

    return result;
  } catch (error) {
    // Handle errors during execution appropriately
    // 실행 중 오류를 적절히 처리
    Logger.error('Error during graph execution', error);

    // Create a safe error response state if possible
    // 가능한 경우 안전한 오류 응답 상태 생성
    if (state && state.context) {
      state.context.executionStatus = 'error';
      state.context.lastError = formatErrorForContext(error);
      return state;
    }

    throw error;
  }
};

// Store the original invoke method and replace it with our safe version
// 원본 invoke 메소드를 저장하고 안전한 버전으로 교체
const originalInvoke = codebotGraph.invoke;
(codebotGraph as any).wrapped_invoke = originalInvoke;

// Replace the invoke method with our safe version
// 원래 invoke 메소드를 안전한 버전으로 교체
codebotGraph.invoke = safeInvoke;

// Preserve any util.inspect.custom symbols or other properties that might be present
// util.inspect.custom 심볼이나 존재할 수 있는 다른 속성 보존
const customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');
if (originalInvoke && typeof originalInvoke === 'object' && customInspectSymbol in originalInvoke) {
  Object.defineProperty(codebotGraph.invoke, customInspectSymbol, {
    enumerable: false,
    configurable: true,
    writable: true,
    value: originalInvoke[customInspectSymbol]
  });
}

// Copy over all other properties and symbols from the original invoke
// 원본 invoke의 모든 다른 속성과 심볼을 복사
if (originalInvoke) {
  try {
    const propertyNames = Object.getOwnPropertyNames(originalInvoke);
    const propertySymbols = Object.getOwnPropertySymbols(originalInvoke);

    // Copy all property names
    for (const prop of propertyNames) {
      if (prop !== 'name' && prop !== 'length' && prop !== 'prototype') {
        try {
          Object.defineProperty(codebotGraph.invoke, prop,
            Object.getOwnPropertyDescriptor(originalInvoke, prop) || {});
        } catch (e) {
          // Silently continue if a property cannot be copied
        }
      }
    }

    // Copy all symbols
    for (const sym of propertySymbols) {
      try {
        Object.defineProperty(codebotGraph.invoke, sym,
          Object.getOwnPropertyDescriptor(originalInvoke, sym) || {});
      } catch (e) {
        // Silently continue if a symbol cannot be copied
      }
    }
  } catch (e) {
    // Fail silently if property copying fails
    Logger.debug('Failed to copy properties from original invoke', e);
  }
}