import { ChatPromptTemplate } from '@langchain/core/prompts';
import { RunnableConfig } from '@langchain/core/runnables';
import { AIMessage } from '@langchain/core/messages';
import { State, Update } from '../state.js';
import { ToolExecutionResult } from '../../types/index.js';
import { EXECUTE_STEP_PROMPT } from '../../prompts/index.js';
import { Logger } from '../../utils/logger.js';

/**
 * Step execution node
 * 단계 실행 노드
 * Executes the current step of the plan
 * 계획의 현재 단계를 실행합니다
 * @param state Current state (현재 상태)
 * @returns State update (상태 업데이트)
 *
 * Generated by Copilot
 */
export async function nodeExecuteStep(state: State): Promise<Update> {
  Logger.nodeEntry('executeStep');

  // Get execution plan and current step
  // 실행 계획 및 현재 단계 가져오기
  const { executionPlan, currentStepIndex, totalSteps } = state.context;

  if (!executionPlan || currentStepIndex === undefined || currentStepIndex >= (totalSteps ?? 0)) {
    Logger.error(`Invalid execution state: plan=${!!executionPlan}, currentStepIndex=${currentStepIndex}, totalSteps=${totalSteps}`);
    Logger.nodeExit('executeStep', 'error');

    return {
      context: {
        ...state.context,
        lastError: {
          message: 'No step to execute.',
          timestamp: new Date().toISOString(),
          type: 'MissingStep',
          stack: undefined
        },
        executionStatus: 'error'
      } as any
    };
  }

  // Get current step
  // 현재 단계 가져오기
  const currentStep = executionPlan.plan[currentStepIndex];
  Logger.nodeAction('executeStep', `Executing step ${currentStepIndex + 1}/${totalSteps}: ${currentStep.step_id}`);
  Logger.graphState(`Current Step (${currentStep.step_id})`, currentStep);

  // Create list of available tools
  // 사용 가능한 도구 목록 생성
  const availableTools = state.tools.map(tool => ({
    name: tool.name,
    description: tool.description
  }));

  // Create step execution prompt
  // 단계 실행 프롬프트 생성
  Logger.nodeAction('executeStep', 'Creating step execution prompt');
  const executeStepPrompt = ChatPromptTemplate.fromTemplate(EXECUTE_STEP_PROMPT);

  // Render prompt
  // 프롬프트 렌더링
  const promptValue = await executeStepPrompt.formatMessages({
    current_step: JSON.stringify(currentStep, null, 2),
    available_tools: JSON.stringify(availableTools, null, 2)
  });

  // Model call configuration
  // 모델 호출 설정
  const config: RunnableConfig = {
    configurable: {
      model: state.context.model
    }
  };

  try {
    // Call model with streaming
    // 스트리밍으로 모델 호출
    Logger.nodeAction('executeStep', 'Calling model for tool selection');
    Logger.nodeModelStart('executeStep', 'Starting model streaming for tool selection');

    // Stream response using the model's streaming capability
    // 모델의 스트리밍 기능을 사용하여 응답 스트리밍
    const stream = await state.context.model.stream(promptValue, config);

    // Collect the full response while streaming individual tokens
    // 개별 토큰을 스트리밍하면서 전체 응답 수집
    let resultContent = '';
    for await (const chunk of stream) {
      const content = chunk.content;
      if (content) {
        // 모델 스트리밍 이벤트 발생
        Logger.nodeModelStreaming('executeStep', content);
        resultContent += content;
      }
    }

    // 모델 응답 완료 이벤트 발생
    Logger.nodeModelEnd('executeStep');

    // Extract tool call
    // 도구 호출 추출
    Logger.nodeAction('executeStep', 'Parsing tool call from model response');
    let toolCall: { tool: string; input: any } | null = null;
    try {
      const content = resultContent;
      const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) || content.match(/({[\s\S]*})/);
      if (jsonMatch) {
        toolCall = JSON.parse(jsonMatch[1]);
      } else if (content.includes('"tool":') && content.includes('"input":')) {
        toolCall = JSON.parse(content);
      }

      // Additional validation for toolCall
      // 도구 호출에 대한 추가 검증
      if (toolCall && (!toolCall.tool || toolCall.tool === null)) {
        throw new Error('Invalid tool call: Tool name cannot be null or empty');
      }
    } catch (error) {
      // Tool call parsing error
      // 도구 호출 파싱 오류
      Logger.error('Failed to parse tool call', error);
      Logger.nodeExit('executeStep', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'Unable to parse tool call.',
            timestamp: new Date().toISOString(),
            type: 'ParseError',
            stack: error instanceof Error ? error.stack : undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // If no tool call
    // 도구 호출이 없는 경우
    if (!toolCall) {
      Logger.nodeAction('executeStep', 'No tool call detected, moving to next step');

      // Move to next step
      // 다음 단계로 이동
      const executionResults = [...(state.context.executionResults || []), {
        step_id: currentStep.step_id,
        result: {
          success: true,
          message: 'Step completed without tool call'
        }
      }];

      const isLastStep = currentStepIndex + 1 >= (totalSteps ?? 0);
      Logger.nodeAction('executeStep', `Moving to next step (${currentStepIndex + 1}/${totalSteps})`);

      if (isLastStep) {
        Logger.nodeAction('executeStep', 'All steps completed');
      }

      Logger.nodeExit('executeStep');
      return {
        messages: [new AIMessage(resultContent)],
        context: {
          ...state.context,
          currentStepIndex: currentStepIndex + 1,
          executionResults,
          executionStatus: isLastStep ? 'completed' : 'running'
        } as any
      };
    }

    // Execute tool
    // 도구 실행
    Logger.nodeAction('executeStep', `Executing tool: ${toolCall.tool}`);

    // 도구 입력값 정규화
    // Normalize tool input
    if (toolCall.tool === 'translate_text') {
      // 특별히 번역 도구를 위한 입력 파라미터 표준화
      // Standardize input parameters specifically for translation tool
      const normalizedInput = { ...toolCall.input };

      // input_text를 text로 변환 (번역 도구가 기대하는 형식으로)
      // Convert input_text to text (format expected by translation tool)
      if (normalizedInput.input_text !== undefined && normalizedInput.text === undefined) {
        normalizedInput.text = normalizedInput.input_text;
        delete normalizedInput.input_text;
      }

      // target_language 매핑 (필요한 경우)
      // Map target_language (if necessary)
      if (normalizedInput.target_language) {
        normalizedInput.targetLanguage = normalizedInput.target_language;
        delete normalizedInput.target_language;
      }

      // 텍스트에서 불필요한 따옴표 제거
      // Remove unnecessary quotes from text
      if (normalizedInput.text && typeof normalizedInput.text === 'string') {
        normalizedInput.text = normalizedInput.text.replace(/^(['"])(.*)\1$/, '$2');
      }

      Logger.nodeAction('executeStep', 'Normalized translation tool input');
      toolCall.input = normalizedInput;
    }

    Logger.toolExecution(toolCall.tool, toolCall.input);

    let toolResult: ToolExecutionResult;
    try {
      // Find tool
      // 도구 찾기
      const tool = state.tools.find(t => t.name === toolCall.tool);

      if (!tool) {
        // Provide available tool names in the error message
        // 오류 메시지에 사용 가능한 도구 이름 제공
        const availableToolNames = state.tools.map(t => t.name).join(', ');
        throw new Error(`Tool not found: ${toolCall.tool}. Available tools: ${availableToolNames}`);
      }

      // Execute tool
      // 도구 실행
      const result = await tool.execute(toolCall.input);
      Logger.toolResult(toolCall.tool, result, result.success !== false);

      toolResult = {
        success: result.success !== false,
        result,
        error: result.success === false ? result.error : undefined
      };
    } catch (error: any) {
      // Tool execution error
      // 도구 실행 오류
      Logger.error(`Tool execution error: ${toolCall.tool}`, error);
      Logger.toolResult(toolCall.tool, { error: error.message }, false);

      toolResult = {
        success: false,
        result: null,
        error: error.message
      };
    }

    // Save execution result
    // 실행 결과 저장
    const executionResults = [...(state.context.executionResults || []), {
      step_id: currentStep.step_id,
      tool: toolCall.tool,
      input: toolCall.input,
      result: toolResult
    }];

    // Move to next step
    // 다음 단계로 이동
    const isLastStep = currentStepIndex + 1 >= (totalSteps ?? 0);
    Logger.nodeAction('executeStep', `Moving to next step (${currentStepIndex + 1}/${totalSteps})`);

    if (isLastStep) {
      Logger.nodeAction('executeStep', 'All steps completed');
    }

    Logger.nodeExit('executeStep');
    return {
      context: {
        ...state.context,
        currentStepIndex: currentStepIndex + 1,
        executionResults,
        executionStatus: isLastStep ? 'completed' : 'running',
        currentTool: null
      } as any
    };
  } catch (error) {
    Logger.error('Error in execute step', error);
    Logger.nodeExit('executeStep', 'error');
    throw error;
  }
}