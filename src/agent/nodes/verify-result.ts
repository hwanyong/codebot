import { ChatPromptTemplate } from '@langchain/core/prompts';
import { RunnableConfig } from '@langchain/core/runnables';
import { AIMessage } from '@langchain/core/messages';
import { State, Update } from '../state.js';
import { VERIFY_RESULT_PROMPT } from '../../prompts/index.js';
import { Logger } from '../../utils/logger.js';

/**
 * Result verification node
 * 결과 검증 노드
 * Verifies execution results and handles errors
 * 실행 결과를 검증하고 오류를 처리합니다
 * @param state Current state (현재 상태)
 * @returns State update (상태 업데이트)
 *
 * Generated by Copilot
 */
export async function nodeVerifyResult(state: State): Promise<Update> {
  Logger.nodeEntry('verifyResult');

  // Get execution results and plan
  // 실행 결과 및 계획 가져오기
  const { executionResults, executionPlan } = state.context;

  if (!executionResults || !executionPlan) {
    Logger.error('Missing execution results or plan for verification');
    Logger.nodeExit('verifyResult', 'error');

    return {
      context: {
        ...state.context,
        lastError: {
          message: 'No execution results to verify.',
          timestamp: new Date().toISOString(),
          type: 'MissingResults',
          stack: undefined
        },
        executionStatus: 'error'
      } as any
    };
  }

  // Create result verification prompt
  // 결과 검증 프롬프트 생성
  Logger.nodeAction('verifyResult', 'Creating verification prompt');
  const verifyResultPrompt = ChatPromptTemplate.fromTemplate(VERIFY_RESULT_PROMPT);

  // Render prompt
  // 프롬프트 렌더링
  const promptValue = await verifyResultPrompt.formatMessages({
    execution_results: JSON.stringify(executionResults, null, 2),
    original_plan: JSON.stringify(executionPlan, null, 2)
  });

  // Model call configuration
  // 모델 호출 설정
  const config: RunnableConfig = {
    configurable: {
      model: state.context.model
    }
  };

  try {
    // Call model with streaming
    // 스트리밍으로 모델 호출
    Logger.nodeAction('verifyResult', 'Calling model for verification');
    Logger.nodeModelStart('verifyResult', 'Starting model streaming for verification');

    // Stream response using the model's streaming capability
    // 모델의 스트리밍 기능을 사용하여 응답 스트리밍
    const stream = await state.context.model.stream(promptValue, config);

    // Collect the full response while streaming individual tokens
    // 개별 토큰을 스트리밍하면서 전체 응답 수집
    let resultContent = '';
    for await (const chunk of stream) {
      const content = chunk.content;
      if (content) {
        // 모델 스트리밍 이벤트 발생
        Logger.nodeModelStreaming('verifyResult', content);
        resultContent += content;
      }
    }

    // 모델 응답 완료 이벤트 발생
    Logger.nodeModelEnd('verifyResult');

    // Parse verification result
    // 검증 결과 파싱
    Logger.nodeAction('verifyResult', 'Parsing verification response');
    let verificationReport;
    try {
      const jsonMatch = resultContent.match(/```json\n([\s\S]*?)\n```/) || resultContent.match(/({[\s\S]*})/);
      if (jsonMatch) {
        verificationReport = JSON.parse(jsonMatch[1]);
      } else {
        verificationReport = JSON.parse(resultContent);
      }
      Logger.graphState('Verification Report', verificationReport);
    } catch (error) {
      Logger.error('Failed to parse verification result', error);
      Logger.nodeExit('verifyResult', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'Unable to parse verification result.',
            timestamp: new Date().toISOString(),
            type: 'ParseError',
            stack: error instanceof Error ? error.stack : undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // If additional steps are needed
    // 추가 단계가 필요한 경우
    if (verificationReport.additional_steps && verificationReport.additional_steps.length > 0) {
      Logger.nodeAction('verifyResult',
        `Verification detected need for additional steps: ${verificationReport.additional_steps.length}`);

      // Add additional steps to execution plan
      // 실행 계획에 추가 단계 추가
      const updatedPlan = {
        ...executionPlan,
        plan: [...executionPlan.plan, ...verificationReport.additional_steps]
      };

      Logger.nodeAction('verifyResult', `Updated plan with ${updatedPlan.plan.length} total steps`);
      Logger.nodeExit('verifyResult');

      return {
        messages: [new AIMessage(resultContent)],
        context: {
          ...state.context,
          executionPlan: updatedPlan,
          totalSteps: updatedPlan.plan.length,
          verificationReport,
          requiresFollowUp: true,
          executionStatus: 'running'
        } as any
      };
    }

    // Verification complete
    // 검증 완료
    Logger.nodeAction('verifyResult',
      `Verification complete: ${verificationReport.success ? 'Success' : 'Failed'}`);
    Logger.nodeExit('verifyResult');

    return {
      messages: [new AIMessage(resultContent)],
      context: {
        ...state.context,
        verificationReport,
        verified: verificationReport.success,
        executionStatus: verificationReport.success ? 'completed' : 'error'
      } as any
    };
  } catch (error) {
    Logger.error('Error in result verification', error);
    Logger.nodeExit('verifyResult', 'error');
    throw error;
  }
}