import { ChatPromptTemplate } from '@langchain/core/prompts';
import { RunnableConfig } from '@langchain/core/runnables';
import { AIMessage } from '@langchain/core/messages';
import { State, Update } from '../state.js';
import { VERIFY_RESULT_PROMPT } from '../../prompts/index.js';
import { Logger } from '../../utils/logger.js';

/**
 * Result verification node
 * 결과 검증 노드
 * Verifies execution results and handles errors
 * 실행 결과를 검증하고 오류를 처리합니다
 * @param state Current state (현재 상태)
 * @returns State update (상태 업데이트)
 *
 * Generated by Copilot
 */
export async function nodeVerifyResult(state: State): Promise<Update> {
  Logger.nodeEntry('verifyResult');

  try {
    // 입력 검증: 실행 결과와 계획이 있는지 확인
    // Input validation: Check if execution results and plan exist
    const { executionResults, executionPlan } = state.context;
    if (!executionResults || !executionPlan) {
      Logger.error('Missing execution results or plan for verification');
      Logger.nodeExit('verifyResult', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'No execution results or plan to verify.',
            timestamp: new Date().toISOString(),
            type: 'MissingResults',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // 실행 결과가 배열인지 확인하고 내용이 있는지 검증
    // Verify execution results is an array and has content
    if (!Array.isArray(executionResults) || executionResults.length === 0) {
      Logger.error('Execution results are empty or invalid');
      Logger.nodeExit('verifyResult', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'Execution results are empty or in an invalid format.',
            timestamp: new Date().toISOString(),
            type: 'InvalidResults',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // 모델 검증: 모델이 설정되어 있는지 확인
    // Validate model: Check if model is configured
    if (!state.context.model) {
      Logger.error('Model is not configured');
      Logger.nodeExit('verifyResult', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'Language model is not configured.',
            timestamp: new Date().toISOString(),
            type: 'ConfigError',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // Create result verification prompt
    // 결과 검증 프롬프트 생성
    Logger.nodeAction('verifyResult', 'Creating verification prompt');
    const verifyResultPrompt = ChatPromptTemplate.fromTemplate(VERIFY_RESULT_PROMPT);

    // Render prompt
    // 프롬프트 렌더링
    const promptValue = await verifyResultPrompt.formatMessages({
      execution_results: JSON.stringify(executionResults, null, 2),
      original_plan: JSON.stringify(executionPlan, null, 2)
    });

    // Model call configuration
    // 모델 호출 설정
    const config: RunnableConfig = {
      configurable: {
        model: state.context.model
      }
    };

    // Call model with streaming
    // 스트리밍으로 모델 호출
    Logger.nodeAction('verifyResult', 'Calling model for verification');
    Logger.nodeModelStart('verifyResult', 'Starting model streaming for verification');

    // Stream response using the model's streaming capability
    // 모델의 스트리밍 기능을 사용하여 응답 스트리밍
    const stream = await state.context.model.stream(promptValue, config);

    // Collect the full response while streaming individual tokens
    // 개별 토큰을 스트리밍하면서 전체 응답 수집
    let resultContent = '';
    for await (const chunk of stream) {
      const content = chunk.content;
      if (content) {
        // 모델 스트리밍 이벤트 발생
        Logger.nodeModelStreaming('verifyResult', content);
        resultContent += content;
      }
    }

    // 응답 검증: 결과 내용이 존재하는지 확인
    // Validate response: Check if result content exists
    if (!resultContent.trim()) {
      Logger.error('Empty response from model');
      Logger.nodeExit('verifyResult', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'Received empty response from language model.',
            timestamp: new Date().toISOString(),
            type: 'ModelError',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // 모델 응답 완료 이벤트 발생
    Logger.nodeModelEnd('verifyResult');

    // Parse verification result
    // 검증 결과 파싱
    Logger.nodeAction('verifyResult', 'Parsing verification response');
    let verificationReport;
    try {
      const jsonMatch = resultContent.match(/```json\n([\s\S]*?)\n```/) || resultContent.match(/({[\s\S]*})/);
      if (jsonMatch) {
        verificationReport = JSON.parse(jsonMatch[1]);
      } else {
        verificationReport = JSON.parse(resultContent);
      }

      // 결과 검증: 필수 필드 확인
      // Validate result: Check required fields
      if (verificationReport.success === undefined) {
        throw new Error('Invalid verification report format. Missing required fields.');
      }

      Logger.graphState('Verification Report', verificationReport);
    } catch (error: any) {
      Logger.error('Failed to parse verification result', error);
      Logger.nodeExit('verifyResult', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: `Unable to parse verification result: ${error.message}`,
            timestamp: new Date().toISOString(),
            type: 'ParseError',
            stack: error instanceof Error ? error.stack : undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // If additional steps are needed
    // 추가 단계가 필요한 경우
    if (verificationReport.additional_steps && verificationReport.additional_steps.length > 0) {
      Logger.nodeAction('verifyResult',
        `Verification detected need for additional steps: ${verificationReport.additional_steps.length}`);

      // 추가 단계 검증: 형식 확인
      // Validate additional steps format
      const invalidStep = verificationReport.additional_steps.find(
        (step: any) => !step.step_id || !step.description || !step.tool
      );

      if (invalidStep) {
        Logger.error('Invalid format for additional step', invalidStep);
        return {
          context: {
            ...state.context,
            lastError: {
              message: 'Invalid format for additional step in verification report',
              timestamp: new Date().toISOString(),
              type: 'InvalidVerificationFormat',
              stack: undefined
            },
            executionStatus: 'error'
          } as any
        };
      }

      // Add additional steps to execution plan
      // 실행 계획에 추가 단계 추가
      const updatedPlan = {
        ...executionPlan,
        plan: [...executionPlan.plan, ...verificationReport.additional_steps]
      };
      Logger.nodeAction('verifyResult', `Updated plan with ${updatedPlan.plan.length} total steps`);
      Logger.nodeExit('verifyResult');
      return {
        messages: [new AIMessage(resultContent)],
        context: {
          ...state.context,
          executionPlan: updatedPlan,
          totalSteps: updatedPlan.plan.length,
          verificationReport,
          requiresFollowUp: true,
          executionStatus: 'running'
        } as any
      };
    }

    // Verification complete
    // 검증 완료
    Logger.nodeAction('verifyResult',
      `Verification complete: ${verificationReport.success ? 'Success' : 'Failed'}`);
    Logger.nodeExit('verifyResult');
    return {
      messages: [new AIMessage(resultContent)],
      context: {
        ...state.context,
        verificationReport,
        verified: verificationReport.success,
        executionStatus: verificationReport.success ? 'completed' : 'error'
      } as any
    };
  } catch (error: any) {
    // 예상치 못한 오류 처리
    // Handle unexpected errors
    Logger.error('Unexpected error in result verification', error);
    Logger.nodeExit('verifyResult', 'error');

    // 오류 발생 시 즉시 중단하고 오류 상태로 전환
    // Stop immediately when an error occurs and change to error status
    return {
      context: {
        ...state.context,
        lastError: {
          message: error.message || 'Unknown error occurred during result verification',
          timestamp: new Date().toISOString(),
          type: 'UnexpectedError',
          stack: error.stack
        },
        executionStatus: 'error'
      } as any
    };
  }
}