import { ChatPromptTemplate } from '@langchain/core/prompts';
import { RunnableConfig } from '@langchain/core/runnables';
import { HumanMessage, AIMessage } from '@langchain/core/messages';
import { State, Update } from '../state.js';
import { ContextState } from '../../types/index.js';
import { TRANSLATE_INPUT_PROMPT } from '../../prompts/index.js';
import { Logger } from '../../utils/logger.js';

/**
 * Input translation node
 * 입력 번역 노드
 * Translates non-English input to English for further processing
 * 비영어 입력을 영어로 번역하여 추가 처리를 준비합니다
 * @param state Current state (현재 상태)
 * @returns State update (상태 업데이트)
 *
 * Generated by Copilot
 */
export async function nodeTranslateInput(state: State): Promise<Update> {
  Logger.nodeEntry('translateInput');

  // Get the last user message
  // 마지막 사용자 메시지 가져오기
  const lastMessage = state.messages[state.messages.length - 1];

  // Check if the message is already in English
  // 메시지가 이미 영어인지 확인
  const isEnglish = /^[a-zA-Z\s.,!?;:()\[\]{}'"0-9-_]+$/.test(lastMessage.content as string);

  // If already in English, don't translate
  // 이미 영어인 경우 번역하지 않음
  if (isEnglish) {
    Logger.nodeAction('translateInput', 'Message is already in English, skipping translation');

    Logger.nodeExit('translateInput');
    return {
      context: {
        ...state.context,
        executionStatus: 'running'
      } as any
    };
  }

  // Create translation prompt
  // 번역 프롬프트 생성
  Logger.nodeAction('translateInput', 'Creating translation prompt');
  // const translatePrompt = ChatPromptTemplate.fromTemplate(TRANSLATE_INPUT_PROMPT);

  // Model call configuration
  // 모델 호출 설정
  const config: RunnableConfig = {
    configurable: {
      model: state.context.model
    }
  };

  try {
    // Use a simplified approach to avoid the formatMessages issue
    // ChatPromptTemplate 문제를 피하기 위해 간소화된 접근 방식 사용
    Logger.nodeAction('translateInput', 'Creating direct prompt');

    // Create a formatted prompt directly
    // 직접 형식화된 프롬프트 생성
    const formattedPrompt = TRANSLATE_INPUT_PROMPT.replace('{user_request}', lastMessage.content as string)
                                             .replace('{translated_message}', '[translated content will be here]');

    const promptValue = [new HumanMessage(formattedPrompt)];

    // Stream response using the model's streaming capability
    // 모델의 스트리밍 기능을 사용하여 응답 스트리밍
    Logger.nodeModelStart('translateInput', 'Starting model streaming for translation');

    const stream = await state.context.model.stream(promptValue, config);

    // Collect the full response while streaming individual tokens
    // 개별 토큰을 스트리밍하면서 전체 응답 수집
    let translatedText = '';
    for await (const chunk of stream) {
      const content = chunk.content;
      if (content) {
        // 모델 스트리밍 이벤트 발생
        translatedText += content;
      }
      Logger.nodeModelStreaming('translateInput', content);
    }

    // 모델 응답 완료 이벤트 발생
    Logger.nodeModelEnd('translateInput');

    // Clean the translated text by removing any explanations or formatting
    // 번역된 텍스트에서 설명이나 형식을 제거하여 정리
    translatedText = translatedText
      // Remove "Translation:" prefix if present
      .replace(/^(Translation:|Translated text:|Here is the translation:|English translation:)/i, '')
      // Remove quotes if present
      .replace(/^['"](.*)['"]$/s, '$1')
      // Extract content between message start/end markers if present
      .replace(/.*?---message start---\s*([\s\S]*?)\s*---message end---.*/s, '$1')
      // Cleanup any trailing explanations
      .replace(/\n\n(Note:|I've translated|This is a translation|explanation:).*/is, '')
      .trim();

    Logger.nodeAction('translateInput', 'Translation completed and cleaned');

    // Create a clean message with just the translated content
    // 번역된 내용만으로 깨끗한 메시지 생성
    const aiMessage = new AIMessage(translatedText);

    const contextUpdate: Partial<ContextState> = {
      ...state.context,
      executionStatus: 'running'
    };

    Logger.nodeExit('translateInput');
    return {
      messages: [aiMessage],
      context: contextUpdate as any
    };
  } catch (error) {
    Logger.error('Error in translation', error);
    Logger.nodeExit('translateInput', 'error');
    throw error;
  }
}