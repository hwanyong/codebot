import { ChatPromptTemplate } from '@langchain/core/prompts';
import { RunnableConfig } from '@langchain/core/runnables';
import { AIMessage } from '@langchain/core/messages';
import { State, Update } from '../state.js';
import { ExecutionPlan, TaskAnalysis } from '../../types/index.js';
import { PLANNING_PROMPT } from '../../prompts/index.js';
import { Logger } from '../../utils/logger.js';

/**
 * Plan execution node
 * 계획 실행 노드
 * Generates execution plan based on task analysis
 * 태스크 분석을 기반으로 실행 계획을 생성합니다
 * @param state Current state (현재 상태)
 * @returns State update (상태 업데이트)
 *
 * Generated by Copilot
 */
export async function nodePlanExecution(state: State): Promise<Update> {
  Logger.nodeEntry('planExecution');

  try {
    // 입력 검증: 태스크 분석 결과 존재 여부 확인
    // Input validation: Check if task analysis exists
    const taskAnalysis = state.context.currentTask;
    if (!taskAnalysis) {
      Logger.error('No task analysis result available');
      Logger.nodeExit('planExecution', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'No task analysis result available.',
            timestamp: new Date().toISOString(),
            type: 'MissingTaskAnalysis',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // 입력 검증: 필수 필드 확인
    // Input validation: Check required fields
    if (!taskAnalysis.task_type || !taskAnalysis.subtasks) {
      Logger.error('Invalid task analysis format');
      Logger.nodeExit('planExecution', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'Invalid task analysis format. Missing required fields.',
            timestamp: new Date().toISOString(),
            type: 'InvalidTaskAnalysis',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // Check if task is a simple response that doesn't require tool execution
    // 도구 실행이 필요 없는 단순 응답인지 확인
    if (taskAnalysis.task_type === 'simple_response' ||
        (taskAnalysis.subtasks && taskAnalysis.subtasks.length === 0)) {
      Logger.nodeAction('planExecution', 'Task requires only direct response without tool execution');
      // Mark this as a direct response case
      // 직접 응답 케이스로 표시
      return {
        context: {
          ...state.context,
          executionPlan: null,
          requiresToolExecution: false,
          directResponse: true,
          executionStatus: 'completed'
        } as any
      };
    }

    // 모델 검증: 모델이 설정되어 있는지 확인
    // Validate model: Check if model is configured
    if (!state.context.model) {
      Logger.error('Model is not configured');
      Logger.nodeExit('planExecution', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'Language model is not configured.',
            timestamp: new Date().toISOString(),
            type: 'ConfigError',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // Create planning prompt with integrated subtask refinement and tool mapping
    // 서브태스크 세분화 및 도구 매핑이 통합된 계획 프롬프트 생성
    Logger.nodeAction('planExecution', 'Creating planning prompt with integrated subtask refinement and tool mapping');
    const planningPrompt = ChatPromptTemplate.fromTemplate(PLANNING_PROMPT);

    // Render prompt with task analysis
    // 태스크 분석을 포함한 프롬프트 렌더링
    const promptValue = await planningPrompt.formatMessages({
      task_analysis: JSON.stringify(taskAnalysis, null, 2)
    });

    // Model call configuration
    // 모델 호출 설정
    const config: RunnableConfig = {
      configurable: {
        model: state.context.model
      }
    };

    // Call model with streaming
    // 스트리밍으로 모델 호출
    Logger.nodeAction('planExecution', 'Calling model for integrated task processing and execution planning');
    Logger.nodeModelStart('planExecution', 'Starting model streaming for subtask refinement, tool mapping, and execution planning');

    // Stream response using the model's streaming capability
    // 모델의 스트리밍 기능을 사용하여 응답 스트리밍
    const stream = await state.context.model.stream(promptValue, config);

    // Collect the full response while streaming individual tokens
    // 개별 토큰을 스트리밍하면서 전체 응답 수집
    let resultContent = '';
    for await (const chunk of stream) {
      const content = chunk.content;
      if (content) {
        // 모델 스트리밍 이벤트 발생
        Logger.nodeModelStreaming('planExecution', content);
        resultContent += content;
      }
    }

    // 응답 검증: 결과 내용이 존재하는지 확인
    // Validate response: Check if result content exists
    if (!resultContent.trim()) {
      Logger.error('Empty response from model');
      Logger.nodeExit('planExecution', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'Received empty response from language model.',
            timestamp: new Date().toISOString(),
            type: 'ModelError',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // 모델 응답 완료 이벤트 발생
    Logger.nodeModelEnd('planExecution');

    // Parse JSON response
    // JSON 응답 파싱
    Logger.nodeAction('planExecution', 'Parsing integrated response');

    try {
      // 정규식 개선: JSON 형식 추출을 위한 더 견고한 패턴
      const jsonMatch = resultContent.match(/```(?:json)?\s*\n([\s\S]*?)\n```/) ||
                        resultContent.match(/```([\s\S]*?)```/) ||
                        resultContent.match(/({[\s\S]*})/);

      let parsedResponse;
      if (jsonMatch) {
        const jsonContent = jsonMatch[1] || jsonMatch[0];
        parsedResponse = JSON.parse(jsonContent.trim());
      } else {
        parsedResponse = JSON.parse(resultContent);
      }

      // 결과 검증 및 처리
      // Validate and process the result

      // 세분화된 서브태스크 검증
      // Validate refined subtasks
      if (!parsedResponse.refined_subtasks || !Array.isArray(parsedResponse.refined_subtasks)) {
        Logger.nodeAction('planExecution', 'No refined subtasks found in response, continuing with original subtasks');
        // 원본 서브태스크 유지
        // Keep original subtasks
      } else {
        Logger.nodeAction('planExecution', `Successfully refined subtasks: ${parsedResponse.refined_subtasks.length}`);
        // 세분화된 서브태스크로 업데이트
        // Update with refined subtasks
        taskAnalysis.subtasks = parsedResponse.refined_subtasks;
      }

      // 실행 계획 검증
      // Validate execution plan
      if (!parsedResponse.plan || !Array.isArray(parsedResponse.plan)) {
        throw new Error('Invalid execution plan format. Missing required plan array.');
      }

      // 실행 계획 생성
      // Create execution plan
      const executionPlan: ExecutionPlan = {
        plan: parsedResponse.plan
      };

      Logger.nodeAction('planExecution', `Execution plan created with ${executionPlan.plan.length} steps`);
      Logger.graphState('Execution Plan', executionPlan);

      // Check if plan is empty or contains only direct response steps
      // 계획이 비어 있거나 직접 응답 단계만 포함하는지 확인
      if (executionPlan.plan.length === 0 ||
          (executionPlan.plan.length === 1 && executionPlan.plan[0].tool === 'direct_response')) {
        Logger.nodeAction('planExecution', 'Plan indicates direct response without tool execution');
        return {
          messages: [new AIMessage(resultContent)],
          context: {
            ...state.context,
            executionPlan,
            requiresToolExecution: false,
            directResponse: true,
            executionStatus: 'completed'
          } as any
        };
      }

      // 재구성된 태스크 분석 결과를 저장
      // Save restructured task analysis
      state.context.currentTask = taskAnalysis;

      // Save execution plan
      // 실행 계획 저장
      Logger.nodeExit('planExecution');
      return {
        messages: [new AIMessage(resultContent)],
        context: {
          ...state.context,
          executionPlan,
          totalSteps: executionPlan.plan.length,
          currentStepIndex: 0,
          executionResults: [],
          requiresToolExecution: true,
          directResponse: false,
          executionStatus: 'running'
        } as any
      };
    } catch (error: any) {
      // JSON 파싱 또는 검증 오류 처리
      // Handle JSON parsing or validation error
      Logger.error('Failed to parse or validate integrated response', error);
      Logger.nodeExit('planExecution', 'error');

      // 대체 파싱 시도: 실행 계획 부분만 추출 시도
      // Try alternative parsing: attempt to extract just the execution plan
      try {
        const planMatch = resultContent.match(/"plan"\s*:\s*(\[\s*\{[\s\S]*?\}\s*\])/);
        if (planMatch) {
          const planJson = `{"plan": ${planMatch[1]}}`;
          const executionPlan = JSON.parse(planJson) as ExecutionPlan;

          // 실행 계획이 유효한지 확인
          if (executionPlan.plan && Array.isArray(executionPlan.plan) && executionPlan.plan.length > 0) {
            Logger.nodeAction('planExecution', `Recovered execution plan with ${executionPlan.plan.length} steps`);

            // 실행 계획 저장하고 진행
            return {
              messages: [new AIMessage("Execution plan was successfully extracted.")],
              context: {
                ...state.context,
                executionPlan,
                totalSteps: executionPlan.plan.length,
                currentStepIndex: 0,
                executionResults: [],
                requiresToolExecution: true,
                directResponse: false,
                executionStatus: 'running'
              } as any
            };
          }
        }

        // 대체 파싱도 실패할 경우 오류 반환
        throw new Error(`Unable to parse execution plan: ${error.message}`);
      } catch (recoveryError) {
        return {
          context: {
            ...state.context,
            lastError: {
              message: `Unable to parse execution plan: ${error.message}`,
              timestamp: new Date().toISOString(),
              type: 'ParseError',
              stack: error instanceof Error ? error.stack : undefined
            },
            executionStatus: 'error'
          } as any
        };
      }
    }
  } catch (error: any) {
    // 예상치 못한 오류 처리
    // Handle unexpected errors
    Logger.error('Unexpected error in plan execution', error);
    Logger.nodeExit('planExecution', 'error');

    // 오류 발생 시 즉시 중단하고 오류 상태로 전환
    // Stop immediately when an error occurs and change to error status
    return {
      context: {
        ...state.context,
        lastError: {
          message: error.message || 'Unknown error occurred during execution planning',
          timestamp: new Date().toISOString(),
          type: 'UnexpectedError',
          stack: error.stack
        },
        executionStatus: 'error'
      } as any
    };
  }
}