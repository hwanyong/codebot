import { ChatPromptTemplate } from '@langchain/core/prompts';
import { RunnableConfig } from '@langchain/core/runnables';
import { AIMessage } from '@langchain/core/messages';
import { State, Update } from '../state.js';
import { ExecutionPlan, TaskAnalysis } from '../../types/index.js';
import { PLANNING_PROMPT } from '../../prompts/index.js';
import { Logger } from '../../utils/logger.js';

// 도구 매핑 프롬프트 템플릿
// Tool mapping prompt template
const TOOL_MAPPING_PROMPT = `You are an AI assistant tasked with mapping potential tools to actually available tools.

Available tools in the system:
- ReadFileTool: Reads the content of a file
- WriteToFileTool: Writes content to a file
- ListFilesTool: Lists files in a directory
- SearchFilesTool: Searches for files in a directory
- ExecuteCommandTool: Executes shell commands
- StoreMemoryTool: Stores data in memory
- RetrieveMemoryTool: Retrieves data from memory

Given the following potential tool names, map them to the most appropriate available tools in the system:

Potential Tool Names:
{potential_tools}

For each potential tool, provide a list of appropriate available tools it can be mapped to.
Format your response as a valid JSON object where keys are potential tool names and values are arrays of available tool names.
For any unfamiliar tool, map it to the ExecuteCommandTool as a fallback since it can execute various commands.

Example output format:
{
  "Code Editor": ["WriteToFileTool"],
  "Terminal": ["ExecuteCommandTool"],
  "File Explorer": ["ListFilesTool", "SearchFilesTool"]
}`;

// 서브태스크 세분화 프롬프트 템플릿
// Subtask refinement prompt template
const SUBTASK_REFINEMENT_PROMPT = `You are an AI assistant tasked with refining and detailing subtasks for a programming task.

Your goal is to break down each subtask into more granular steps that provide clear, specific guidance for execution.

Here are the current subtasks:
{subtasks}

For each subtask above:
1. Break it down into 2-3 more specific steps
2. Make each step focused on a single action
3. Ensure the steps are in logical order
4. Preserve all the original information and dependencies
5. Add detailed information about tool usage for each step

Each refined subtask should include:
- id: A unique identifier (original_id.step_number)
- description: A clear description of the specific action
- potential_tools: The tools needed for this specific step
- dependencies: Dependencies for this step (can reference other refined step IDs)

Format your response as a valid JSON array of the refined subtasks.

Example of refined subtask structure:
[
  {
    "id": "1.1",
    "description": "Check if gcc compiler is installed",
    "potential_tools": ["Terminal/shell"],
    "dependencies": []
  },
  {
    "id": "1.2",
    "description": "Create C source file with example code",
    "potential_tools": ["Code Editor"],
    "dependencies": ["1.1"]
  }
]`;

/**
 * 잠재적 도구들을 실제 사용 가능한 도구로 매핑합니다.
 * Maps potential tools to actually available tools using AI.
 *
 * @param potentialTools 잠재적 도구 배열
 * @param model 사용할 AI 모델
 * @returns 매핑된 도구 객체 (key: 잠재적 도구, value: 사용 가능 도구 배열)
 *
 * Generated by Copilot
 */
async function mapToolsUsingAI(potentialTools: string[], model: any): Promise<Record<string, string[]>> {
  try {
    // 입력 검증
    if (!potentialTools || potentialTools.length === 0) {
      Logger.error('Empty potential tools list for AI mapping');
      return {};
    }

    // 잠재적 도구 목록을 문자열로 변환
    const potentialToolsText = potentialTools.map(tool => `- ${tool}`).join('\n');

    // 프롬프트 생성
    const prompt = ChatPromptTemplate.fromTemplate(TOOL_MAPPING_PROMPT);
    const promptMessages = await prompt.formatMessages({
      potential_tools: potentialToolsText
    });

    // 모델 호출 설정
    const config: RunnableConfig = {
      configurable: { model }
    };

    Logger.nodeAction('planExecution', 'Calling AI for tool mapping');

    // AI 모델 호출
    const response = await model.invoke(promptMessages, config);
    const resultContent = response.content;

    // JSON 파싱
    let toolMapping: Record<string, string[]>;
    try {
      // JSON 형식 추출 시도
      const jsonMatch = resultContent.match(/```json\n([\s\S]*?)\n```/) ||
                        resultContent.match(/```\n([\\s\S]*?)\n```/) ||
                        resultContent.match(/{[\s\S]*?}/);

      if (jsonMatch) {
        toolMapping = JSON.parse(jsonMatch[0].startsWith('{') ? jsonMatch[0] : jsonMatch[1]);
      } else {
        toolMapping = JSON.parse(resultContent);
      }

      Logger.nodeAction('planExecution', `Successfully mapped ${Object.keys(toolMapping).length} tools`);
      return toolMapping;
    } catch (error) {
      Logger.error('Failed to parse AI tool mapping response', error);

      // 파싱 실패 시 기본 매핑 반환
      const defaultMapping: Record<string, string[]> = {};
      for (const tool of potentialTools) {
        defaultMapping[tool] = ["ExecuteCommandTool"]; // 기본값으로 ExecuteCommandTool 사용
      }
      return defaultMapping;
    }
  } catch (error) {
    Logger.error('Error during AI tool mapping', error);

    // 오류 발생 시 기본 매핑 반환
    const defaultMapping: Record<string, string[]> = {};
    for (const tool of potentialTools) {
      defaultMapping[tool] = ["ExecuteCommandTool"]; // 기본값으로 ExecuteCommandTool 사용
    }
    return defaultMapping;
  }
}

/**
 * subtask를 AI를 사용하여 세분화합니다.
 * Refines subtasks into more detailed steps using AI.
 *
 * @param subtasks 세분화할 서브태스크 배열
 * @param model 사용할 AI 모델
 * @returns 세분화된 서브태스크 배열
 *
 * Generated by Copilot
 */
async function refineSubtasksUsingAI(subtasks: any[], model: any): Promise<any[]> {
  try {
    // 입력 검증
    if (!subtasks || subtasks.length === 0) {
      Logger.error('Empty subtasks list for AI refinement');
      return subtasks;
    }

    // 서브태스크를 JSON 형식으로 변환
    const subtasksJson = JSON.stringify(subtasks, null, 2);

    // 프롬프트 생성
    const prompt = ChatPromptTemplate.fromTemplate(SUBTASK_REFINEMENT_PROMPT);
    const promptMessages = await prompt.formatMessages({
      subtasks: subtasksJson
    });

    // 모델 호출 설정
    const config: RunnableConfig = {
      configurable: { model }
    };

    Logger.nodeAction('planExecution', 'Calling AI for subtask refinement');

    // AI 모델 호출
    const response = await model.invoke(promptMessages, config);
    const resultContent = response.content;

    // JSON 파싱
    try {
      // JSON 형식 추출 시도
      const jsonMatch = resultContent.match(/```json\n([\s\S]*?)\n```/) ||
                        resultContent.match(/```\n([\\s\S]*?)\n```/) ||
                        resultContent.match(/(\[[\s\S]*?\])/);

      let refinedSubtasks: any[];
      if (jsonMatch) {
        refinedSubtasks = JSON.parse(jsonMatch[0].startsWith('[') ? jsonMatch[0] : jsonMatch[1]);
      } else {
        refinedSubtasks = JSON.parse(resultContent);
      }

      // 세분화된 서브태스크 유효성 검증
      if (!Array.isArray(refinedSubtasks)) {
        throw new Error('AI response is not a valid array');
      }

      // 필수 필드 검증
      const validSubtasks = refinedSubtasks.filter(task =>
        task && task.id && task.description &&
        Array.isArray(task.potential_tools) && Array.isArray(task.dependencies)
      );

      if (validSubtasks.length < refinedSubtasks.length) {
        Logger.error(`Some refined subtasks (${refinedSubtasks.length - validSubtasks.length}) are invalid and will be filtered out`);
      }

      Logger.nodeAction('planExecution', `Successfully refined subtasks from ${subtasks.length} to ${validSubtasks.length}`);
      return validSubtasks;
    } catch (error) {
      Logger.error('Failed to parse AI subtask refinement response', error);
      // 파싱 실패 시 원래 서브태스크 반환
      return subtasks;
    }
  } catch (error) {
    Logger.error('Error during AI subtask refinement', error);
    // 오류 발생 시 원래 서브태스크 반환
    return subtasks;
  }
}

/**
 * 서브태스크의 잠재적 도구 목록을 AI를 사용하여 실제 도구로 매핑
 * Maps potential tools in subtasks to actual tools using AI
 *
 * @param subtasks 서브태스크 배열
 * @param model 사용할 AI 모델
 * @returns 도구가 매핑된 서브태스크 배열
 *
 * Generated by Copilot
 */
async function mapSubtaskToolsUsingAI(subtasks: any[], model: any): Promise<any[]> {
  try {
    // 모든 잠재적 도구를 수집
    const allPotentialTools = new Set<string>();
    subtasks.forEach(subtask => {
      if (Array.isArray(subtask.potential_tools)) {
        subtask.potential_tools.forEach((tool: string) => allPotentialTools.add(tool));
      }
    });

    const potentialToolsArray = Array.from(allPotentialTools);

    // 잠재적 도구가 없는 경우 원본 반환
    if (potentialToolsArray.length === 0) {
      return subtasks;
    }

    // AI를 사용하여 도구 매핑
    const toolMapping = await mapToolsUsingAI(potentialToolsArray, model);

    // 매핑 결과를 적용
    return subtasks.map(subtask => {
      const actualTools = new Set<string>();

      if (Array.isArray(subtask.potential_tools)) {
        subtask.potential_tools.forEach((tool: string) => {
          if (toolMapping[tool]) {
            toolMapping[tool].forEach(mappedTool => actualTools.add(mappedTool));
          } else {
            // 매핑이 없는 도구는 기본 도구로 처리
            actualTools.add("ExecuteCommandTool");
          }
        });
      }

      // 원본 서브태스크에 매핑된 도구 추가
      return {
        ...subtask,
        actual_tools: Array.from(actualTools)
      };
    });
  } catch (error) {
    Logger.error('Error mapping subtask tools with AI', error);

    // 오류 발생 시 기본 매핑 반환
    return subtasks.map(subtask => {
      return {
        ...subtask,
        actual_tools: ["ExecuteCommandTool"] // 기본값으로 ExecuteCommandTool 사용
      };
    });
  }
}

/**
 * Plan execution node
 * 계획 실행 노드
 * Generates execution plan based on task analysis
 * 태스크 분석을 기반으로 실행 계획을 생성합니다
 * @param state Current state (현재 상태)
 * @returns State update (상태 업데이트)
 *
 * Generated by Copilot
 */
export async function nodePlanExecution(state: State): Promise<Update> {
  Logger.nodeEntry('planExecution');

  try {
    // 입력 검증: 태스크 분석 결과 존재 여부 확인
    // Input validation: Check if task analysis exists
    const taskAnalysis = state.context.currentTask;
    if (!taskAnalysis) {
      Logger.error('No task analysis result available');
      Logger.nodeExit('planExecution', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'No task analysis result available.',
            timestamp: new Date().toISOString(),
            type: 'MissingTaskAnalysis',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // 입력 검증: 필수 필드 확인
    // Input validation: Check required fields
    if (!taskAnalysis.task_type || !taskAnalysis.subtasks) {
      Logger.error('Invalid task analysis format');
      Logger.nodeExit('planExecution', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'Invalid task analysis format. Missing required fields.',
            timestamp: new Date().toISOString(),
            type: 'InvalidTaskAnalysis',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // Check if task is a simple response that doesn't require tool execution
    // 도구 실행이 필요 없는 단순 응답인지 확인
    if (taskAnalysis.task_type === 'simple_response' ||
        (taskAnalysis.subtasks && taskAnalysis.subtasks.length === 0)) {
      Logger.nodeAction('planExecution', 'Task requires only direct response without tool execution');
      // Mark this as a direct response case
      // 직접 응답 케이스로 표시
      return {
        context: {
          ...state.context,
          executionPlan: null,
          requiresToolExecution: false,
          directResponse: true,
          executionStatus: 'completed'
        } as any
      };
    }

    // 모델 검증: 모델이 설정되어 있는지 확인
    // Validate model: Check if model is configured
    if (!state.context.model) {
      Logger.error('Model is not configured');
      Logger.nodeExit('planExecution', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'Language model is not configured.',
            timestamp: new Date().toISOString(),
            type: 'ConfigError',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // Step 1: AI를 사용하여 서브태스크 세분화
    // Step 1: Refine subtasks using AI
    Logger.nodeAction('planExecution', 'Refining subtasks into more detailed steps');
    const refinedSubtasks = await refineSubtasksUsingAI(taskAnalysis.subtasks, state.context.model);

    // Step 2: AI를 사용하여 잠재적 도구를 실제 사용 가능한 도구로 매핑
    // Step 2: Map potential tools to actually available tools using AI
    Logger.nodeAction('planExecution', 'Mapping potential tools to available tools');
    const mappedSubtasks = await mapSubtaskToolsUsingAI(refinedSubtasks, state.context.model);

    // 재구성된 태스크 분석 생성
    // Create restructured task analysis
    const restructuredTaskAnalysis = {
      ...taskAnalysis,
      subtasks: mappedSubtasks
    } as TaskAnalysis;

    Logger.graphState('Restructured Task Analysis', restructuredTaskAnalysis);

    // Create planning prompt
    // 계획 실행 프롬프트 생성
    Logger.nodeAction('planExecution', 'Creating planning prompt');
    const planningPrompt = ChatPromptTemplate.fromTemplate(PLANNING_PROMPT);

    // Render prompt
    // 프롬프트 렌더링
    const promptValue = await planningPrompt.formatMessages({
      task_analysis: JSON.stringify(restructuredTaskAnalysis, null, 2)
    });

    // Model call configuration
    // 모델 호출 설정
    const config: RunnableConfig = {
      configurable: {
        model: state.context.model
      }
    };

    // Call model with streaming
    // 스트리밍으로 모델 호출
    Logger.nodeAction('planExecution', 'Calling model for execution planning');
    Logger.nodeModelStart('planExecution', 'Starting model streaming for execution planning');

    // Stream response using the model's streaming capability
    // 모델의 스트리밍 기능을 사용하여 응답 스트리밍
    const stream = await state.context.model.stream(promptValue, config);

    // Collect the full response while streaming individual tokens
    // 개별 토큰을 스트리밍하면서 전체 응답 수집
    let resultContent = '';
    for await (const chunk of stream) {
      const content = chunk.content;
      if (content) {
        // 모델 스트리밍 이벤트 발생
        Logger.nodeModelStreaming('planExecution', content);
        resultContent += content;
      }
    }

    // 응답 검증: 결과 내용이 존재하는지 확인
    // Validate response: Check if result content exists
    if (!resultContent.trim()) {
      Logger.error('Empty response from model');
      Logger.nodeExit('planExecution', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: 'Received empty response from language model.',
            timestamp: new Date().toISOString(),
            type: 'ModelError',
            stack: undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // 모델 응답 완료 이벤트 발생
    Logger.nodeModelEnd('planExecution');

    // Parse JSON response
    // JSON 응답 파싱
    Logger.nodeAction('planExecution', 'Parsing execution plan');
    let executionPlan: ExecutionPlan;
    try {
      const jsonMatch = resultContent.match(/```json\n([\s\S]*?)\n```/) ||
                        resultContent.match(/```\n([\\s\S]*?)\n```/) ||
                        resultContent.match(/({[\s\S]*})/);

      if (jsonMatch) {
        executionPlan = JSON.parse(jsonMatch[0].startsWith('{') ? jsonMatch[0] : jsonMatch[1]);
      } else {
        executionPlan = JSON.parse(resultContent);
      }

      // 결과 검증: 필수 필드 확인
      // Validate result: Check required fields
      if (!executionPlan.plan || !Array.isArray(executionPlan.plan)) {
        throw new Error('Invalid execution plan format. Missing required fields.');
      }

      Logger.nodeAction('planExecution', `Execution plan created with ${executionPlan.plan.length} steps`);
      Logger.graphState('Execution Plan', executionPlan);
    } catch (error: any) {
      Logger.error('Failed to parse execution plan', error);
      Logger.nodeExit('planExecution', 'error');
      return {
        context: {
          ...state.context,
          lastError: {
            message: `Unable to parse execution plan: ${error.message}`,
            timestamp: new Date().toISOString(),
            type: 'ParseError',
            stack: error instanceof Error ? error.stack : undefined
          },
          executionStatus: 'error'
        } as any
      };
    }

    // Check if plan is empty or contains only direct response steps
    // 계획이 비어 있거나 직접 응답 단계만 포함하는지 확인
    if (executionPlan.plan.length === 0 ||
        (executionPlan.plan.length === 1 && executionPlan.plan[0].tool === 'direct_response')) {
      Logger.nodeAction('planExecution', 'Plan indicates direct response without tool execution');
      return {
        messages: [new AIMessage(resultContent)],
        context: {
          ...state.context,
          executionPlan,
          requiresToolExecution: false,
          directResponse: true,
          executionStatus: 'completed'
        } as any
      };
    }

    // 재구성된 태스크 분석 결과를 저장
    // Save restructured task analysis
    state.context.currentTask = restructuredTaskAnalysis;

    // Save execution plan
    // 실행 계획 저장
    Logger.nodeExit('planExecution');
    return {
      messages: [new AIMessage(resultContent)],
      context: {
        ...state.context,
        executionPlan,
        totalSteps: executionPlan.plan.length,
        currentStepIndex: 0,
        executionResults: [],
        requiresToolExecution: true,
        directResponse: false,
        executionStatus: 'running'
      } as any
    };
  } catch (error: any) {
    // 예상치 못한 오류 처리
    // Handle unexpected errors
    Logger.error('Unexpected error in plan execution', error);
    Logger.nodeExit('planExecution', 'error');

    // 오류 발생 시 즉시 중단하고 오류 상태로 전환
    // Stop immediately when an error occurs and change to error status
    return {
      context: {
        ...state.context,
        lastError: {
          message: error.message || 'Unknown error occurred during execution planning',
          timestamp: new Date().toISOString(),
          type: 'UnexpectedError',
          stack: error.stack
        },
        executionStatus: 'error'
      } as any
    };
  }
}