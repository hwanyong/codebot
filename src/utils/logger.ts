import chalk from 'chalk';
import { EventManager, NodeEventType } from './events.js';
import { LOGGER_DEFAULTS } from './constants.js';
import { ConfigManager } from '../config/manager.js';

/**
 * Logger configuration interface
 * 로거 구성 인터페이스
 */
export interface LoggerConfig {
  /** Enable verbose logging */
  verbose?: boolean;
  /** Enable debug logging */
  debug?: boolean;
  /** Enable graph state logging */
  graphState?: boolean;
  /** Enable tool logging */
  tools?: boolean;
  /** Enable AI stream output for all nodes */
  aiStream?: boolean;
  /** Configure node-specific AI stream visibility */
  nodeStreamConfig?: Record<string, boolean>;
  /** Always visible nodes regardless of debug mode */
  alwaysVisibleNodes?: string[];
}

/**
 * Logger class for managing application logs
 * 애플리케이션 로그를 관리하는 로거 클래스
 *
 * Generated by Copilot
 */
export class Logger {
  private static _config: Required<LoggerConfig> = {
    verbose: false,
    debug: false,
    graphState: false,
    tools: true,
    aiStream: false,
    nodeStreamConfig: {},
    alwaysVisibleNodes: LOGGER_DEFAULTS.ALWAYS_VISIBLE_NODES
  };

  private static _eventManager = EventManager.getInstance();
  private static _configManager = ConfigManager.getInstance();
  private static _configChangeRemover: (() => void) | null = null;

  // 마지막 스트리밍 노드를 추적하기 위한 변수
  private static _lastStreamingNode: string | null = null;

  // 마지막 스트림 출력 내용을 추적하기 위한 변수 (중복 출력 방지)
  private static _lastStreamOutput: string = '';

  // 누적된 스트리밍 내용을 저장하기 위한 변수
  private static _accumulatedOutput: string = '';

  // 노드별 스트리밍 상태를 추적하는 맵 추가
  private static _nodeStreamingStates: Map<string, {
    isStreaming: boolean;
    accumulatedOutput: string;
    lastUpdateTime: number;
  }> = new Map();

  // 활성 스트리밍 노드를 관리하는 큐 (순서 보장을 위함)
  private static _activeStreamingNodes: string[] = [];

  // 스트림 출력 충돌을 방지하기 위한 락
  private static _streamingLock: boolean = false;

  // 스트림 종료 타이머 ID
  private static _streamCleanupTimers: Map<string, NodeJS.Timeout> = new Map();

  // 중복 출력 방지를 위한 플래그 추가
  private static _hasShownCompletionMessage: boolean = false;

  /**
   * 정적 초기화 블록
   * 클래스가 로드될 때 설정 변경 리스너 설정
   *
   * Generated by Copilot
   */
  static {
    // 설정 파일 변경 리스너 설정
    Logger._setupConfigChangeListener();
  }

  /**
   * 설정 파일 변경 감지 리스너를 설정합니다.
   *
   * Generated by Copilot
   */
  private static _setupConfigChangeListener(): void {
    // 기존 리스너 제거
    if (Logger._configChangeRemover) {
      Logger._configChangeRemover();
    }

    // 새 리스너 등록
    Logger._configChangeRemover = Logger._configManager.addChangeListener(config => {
      // 설정 파일이 변경되면 로깅 설정 업데이트
      if (config.logging) {
        // 현재 명령줄 옵션은 유지하고 설정 파일의 값만 업데이트
        const currentConfig = { ...Logger._config };

        // aiStream이 명령줄에서 명시적으로 설정되지 않은 경우에만 설정 파일 값 적용
        if (!Logger._commandLineOptions.aiStream && config.logging.defaultAiStream !== undefined) {
          currentConfig.aiStream = config.logging.defaultAiStream;
        }

        // alwaysVisibleNodes 업데이트 (명령줄에서 설정된 값은 없으므로 항상 적용)
        if (config.logging.alwaysVisibleNodes) {
          currentConfig.alwaysVisibleNodes = config.logging.alwaysVisibleNodes;
        }

        // 로깅 설정 업데이트
        Logger.configure(currentConfig, false);

        // 로깅 설정이 업데이트되었음을 디버그 메시지로 표시
        if (Logger._config.debug) {
          console.log(chalk.yellow('[Logger] Configuration updated from config file'));
        }
      }
    });
  }

  /**
   * 명령줄에서 직접 설정된 옵션을 추적하기 위한 객체
   *
   * Generated by Copilot
   */
  private static _commandLineOptions: {
    verbose?: boolean;
    debug?: boolean;
    aiStream?: boolean;
  } = {};

  /**
   * Configure logger settings
   * 로거 설정 구성
   * @param config Logger configuration
   * @param isCommandLine 명령줄에서 직접 호출된 설정인지 여부
   *
   * Generated by Copilot
   */
  public static configure(config: LoggerConfig, isCommandLine: boolean = true): void {
    try {
      // 명령줄에서 직접 설정된 옵션 추적
      if (isCommandLine) {
        if (config.verbose !== undefined) Logger._commandLineOptions.verbose = config.verbose;
        if (config.debug !== undefined) Logger._commandLineOptions.debug = config.debug;
        if (config.aiStream !== undefined) Logger._commandLineOptions.aiStream = config.aiStream;

        // 설정 파일도 함께 업데이트 (alwaysVisibleNodes 및 설정 파일에 저장될 값들)
        if (config.alwaysVisibleNodes) {
          Logger._configManager.setAlwaysVisibleNodes(config.alwaysVisibleNodes);
        }

        // aiStream 값이 명시적으로 설정된 경우 설정 파일도 업데이트
        if (config.aiStream !== undefined) {
          Logger._configManager.setDefaultAiStream(config.aiStream);
        }
      }

      // 기존 설정 유지하면서 새 설정으로 업데이트
      Logger._config = {
        ...Logger._config,
        ...config,
        // nodeStreamConfig가 제공된 경우 병합
        nodeStreamConfig: {
          ...Logger._config.nodeStreamConfig,
          ...(config.nodeStreamConfig || {})
        },
        // alwaysVisibleNodes가 제공된 경우 덮어쓰기 아니면 기존 값 유지
        alwaysVisibleNodes: config.alwaysVisibleNodes || Logger._config.alwaysVisibleNodes
      };

      // 디버그 모드가 활성화된 경우 설정 내용 출력
      if (Logger._config.debug) {
        console.log(chalk.yellow('[Logger] Configuration updated:'), {
          verbose: Logger._config.verbose,
          debug: Logger._config.debug,
          aiStream: Logger._config.aiStream,
          alwaysVisibleNodes: Logger._config.alwaysVisibleNodes.length
        });
      }
    } catch (error) {
      // 설정 중 오류 발생시 안전하게 처리
      console.error(chalk.red('[Logger] Failed to update configuration:'), error);
      // 기본 설정 유지
    }
  }

  /**
   * 초기화: 설정 파일에서 기본 설정을 로드합니다.
   * 아직 Logger가 설정되지 않은 경우 애플리케이션 시작 시 호출해야 합니다.
   *
   * Generated by Copilot
   */
  public static initialize(): void {
    try {
      // 설정 파일에서 로깅 설정 로드
      const loggingConfig = Logger._configManager.getLoggingConfig();

      // 기본 설정 적용 (명령줄 옵션은 아님)
      Logger.configure({
        aiStream: loggingConfig.defaultAiStream,
        alwaysVisibleNodes: loggingConfig.alwaysVisibleNodes
      }, false);

      if (Logger._config.debug) {
        console.log(chalk.yellow('[Logger] Initialized with settings from config file'));
      }
    } catch (error) {
      console.error(chalk.red('[Logger] Failed to initialize from config file:'), error);
    }
  }

  /**
   * Returns whether verbose mode is enabled
   * verbose 모드 활성화 여부 반환
   * @returns Whether verbose mode is enabled
   *
   * Generated by Copilot
   */
  public static isVerbose(): boolean {
    return Logger._config.verbose;
  }

  /**
   * Returns whether debug mode is enabled
   * debug 모드 활성화 여부 반환
   * @returns Whether debug mode is enabled
   *
   * Generated by Copilot
   */
  public static isDebug(): boolean {
    return Logger._config.debug;
  }

  /**
   * Returns whether AI streaming is enabled for a specific node
   * 특정 노드에 대한 AI 스트리밍 활성화 여부 반환
   * @param nodeName Node name
   * @returns Whether AI streaming is enabled for the node
   *
   * Generated by Copilot
   */
  public static isStreamEnabled(nodeName: string): boolean {
    return Logger._isStreamingVisibleForNode(nodeName);
  }

  /**
   * Check if streaming should be visible for a specific node
   * 특정 노드에 대한 스트리밍 가시성 확인
   * @param nodeName Node name
   * @returns Whether streaming should be visible
   *
   * Generated by Copilot
   */
  private static _isStreamingVisibleForNode(nodeName: string): boolean {
    try {
      // 노드가 유효하지 않으면 기본값 반환
      if (!nodeName) {
        return Boolean(Logger._config.aiStream || Logger._config.debug);
      }

      // 1. 노드별 개별 설정이 있는 경우 우선 적용
      if (nodeName in Logger._config.nodeStreamConfig) {
        return Logger._config.nodeStreamConfig[nodeName];
      }

      // 2. 항상 표시해야 하는 노드 목록에 있는 경우
      if (Logger._config.alwaysVisibleNodes.includes(nodeName)) {
        return true;
      }

      // 3. 그 외에는 글로벌 AI 스트림 설정이나 디버그 모드에 따라 결정
      return Boolean(Logger._config.aiStream || Logger._config.debug);
    } catch (error) {
      // 오류 발생 시 안전하게 기본값 반환
      console.error(chalk.red(`[Logger] Error checking stream visibility for node ${nodeName}:`), error);
      // 기본적으로 디버그 모드일 때만 보이게 설정
      return Logger._config.debug;
    }
  }

  /**
   * Log node entry
   * 노드 진입 로깅
   * @param nodeName Node name
   */
  public static nodeEntry(nodeName: string): void {
    if (Logger._config.verbose) {
      console.log(chalk.cyan(`[${nodeName}] Entry`));
    }

    // 노드 시작 이벤트 방출
    Logger._eventManager.emit({
      nodeName,
      eventType: NodeEventType.START
    });
  }

  /**
   * Log node action
   * 노드 액션 로깅
   * @param nodeName Node name
   * @param action Action description
   */
  public static nodeAction(nodeName: string, action: string): void {
    if (Logger._config.verbose) {
      console.log(chalk.blue(`[${nodeName}] ${action}`));
    }
  }

  /**
   * Log node model activity start
   * 노드 모델 활동 시작 로깅
   * @param nodeName Node name
   * @param action Action description
   */
  public static nodeModelStart(nodeName: string, action: string): void {
    if (Logger._config.verbose) {
      console.log(chalk.magenta(`[${nodeName}] ${action}`));
    }

    // 노드의 스트리밍 상태 초기화
    Logger._nodeStreamingStates.set(nodeName, {
      isStreaming: false,
      accumulatedOutput: '',
      lastUpdateTime: Date.now()
    });

    // 활성 노드 배열에 추가
    if (!Logger._activeStreamingNodes.includes(nodeName)) {
      Logger._activeStreamingNodes.push(nodeName);
    }

    // 기존 스트림 정리 타이머가 있다면 제거
    if (Logger._streamCleanupTimers.has(nodeName)) {
      clearTimeout(Logger._streamCleanupTimers.get(nodeName));
      Logger._streamCleanupTimers.delete(nodeName);
    }

    // 모델 시작 이벤트 방출
    Logger._eventManager.emit({
      nodeName,
      eventType: NodeEventType.MODEL_START,
      payload: { action }
    });
  }

  /**
   * Log node model streaming
   * 노드 모델 스트리밍 로깅
   * @param nodeName Node name
   * @param content Stream content
   *
   * Generated by Copilot
   */
  public static nodeModelStreaming(nodeName: string, content: string): void {
    try {
      // 컨텐츠가 비어있으면 처리하지 않음
      if (!content.trim()) {
        return;
      }

      // 해당 노드에 대한 스트리밍 가시성 확인
      const isVisible = Logger._isStreamingVisibleForNode(nodeName);
      if (!isVisible) {
        return;
      }

      // 모델 스트리밍 이벤트 방출
      Logger._eventManager.emit({
        nodeName,
        eventType: NodeEventType.MODEL_STREAMING,
        payload: { content }
      });

      // 디버그 모드나 특별히 설정된 노드의 경우 내용 출력
      if (Logger._config.debug || Logger._config.aiStream ||
          Logger._config.alwaysVisibleNodes.includes(nodeName)) {

        // 노드의 현재 스트리밍 상태 가져오기
        let nodeState = Logger._nodeStreamingStates.get(nodeName);
        if (!nodeState) {
          // 상태가 없으면 새로 생성
          nodeState = {
            isStreaming: false,
            accumulatedOutput: '',
            lastUpdateTime: Date.now()
          };
          Logger._nodeStreamingStates.set(nodeName, nodeState);

          // 활성 노드 목록에 추가
          if (!Logger._activeStreamingNodes.includes(nodeName)) {
            Logger._activeStreamingNodes.push(nodeName);
          }
        }

        // 노드가 아직 스트리밍 중이 아닌 경우 시작 메시지 출력
        if (!nodeState.isStreaming) {
          console.log(chalk.magenta(`\n[${nodeName} 스트림 시작]`));
          nodeState.isStreaming = true;
        }

        // 누적된 출력에서 새로운 부분만 추출하여 출력
        if (content.length > nodeState.accumulatedOutput.length) {
          // 이전에 출력하지 않은 새 부분만 가져옴
          const newContent = content.substring(nodeState.accumulatedOutput.length);

          // <think> 태그 및 특수 토큰 필터링
          let filteredContent = newContent;

          // <think> 태그 패턴 필터링 (다양한 AI 제공자에 맞게 유연하게 처리)
          const thinkTagPattern = /<\s*think\s*>|<\s*\/\s*think\s*>/gi;
          filteredContent = filteredContent.replace(thinkTagPattern, '');

          // 새 내용이 있는 경우에만 출력
          if (filteredContent) {
            // 락 획득 시도
            if (!Logger._streamingLock) {
              Logger._streamingLock = true;
              try {
                // 원본 개행을 존중하여 출력
                process.stdout.write(filteredContent);
              } finally {
                // 락 해제
                Logger._streamingLock = false;
              }
            } else {
              // 락을 획득하지 못한 경우 약간 지연 후 재시도 (선택적)
              setTimeout(() => {
                if (!Logger._streamingLock) {
                  Logger._streamingLock = true;
                  try {
                    process.stdout.write(filteredContent);
                  } finally {
                    Logger._streamingLock = false;
                  }
                }
              }, 10);
            }
          }

          // 현재 내용을 누적 출력에 저장
          nodeState.accumulatedOutput = content;
          // 마지막 업데이트 시간 갱신
          nodeState.lastUpdateTime = Date.now();
        }
      }
    } catch (error) {
      // 스트림 출력 처리 중 오류가 발생해도 애플리케이션이 중단되지 않도록 처리
      console.error(chalk.red(`[Logger] Error in nodeModelStreaming for ${nodeName}:`), error);
      // 오류 발생 시 락 강제 해제
      Logger._streamingLock = false;
    }
  }

  /**
   * Log node model activity end
   * 노드 모델 활동 종료 로깅
   * @param nodeName Node name
   *
   * Generated by Copilot
   */
  public static nodeModelEnd(nodeName: string): void {
    try {
      // 노드의 스트리밍 상태 가져오기
      const nodeState = Logger._nodeStreamingStates.get(nodeName);

      // 현재 노드가 스트리밍 중이었던 경우에만 스트림 종료 메시지 출력
      if (nodeState && nodeState.isStreaming) {
        console.log(chalk.magenta(`\n[${nodeName} 스트림 종료]\n`));

        // 노드 스트리밍 상태 초기화
        nodeState.isStreaming = false;
        nodeState.accumulatedOutput = '';

        // 활성 노드 목록에서 제거
        const index = Logger._activeStreamingNodes.indexOf(nodeName);
        if (index !== -1) {
          Logger._activeStreamingNodes.splice(index, 1);
        }
      }

      // 안정성을 위해 지연된 정리 작업 설정 (혹시 모를 dangling 스트림 방지)
      const cleanupTimer = setTimeout(() => {
        Logger._nodeStreamingStates.delete(nodeName);
        Logger._streamCleanupTimers.delete(nodeName);

        // 열려있는 스트림이 없으면 스트림 처리 완료되었다는 메시지 출력
        if (Logger._activeStreamingNodes.length === 0 &&
            Logger._nodeStreamingStates.size === 0 &&
            // 중복 출력 방지를 위한 플래그 추가
            !Logger._hasShownCompletionMessage) {
          // 중복 출력 방지 플래그 설정
          Logger._hasShownCompletionMessage = true;
          console.log(chalk.cyan('\n--- AI 응답 스트림 완료됨 ---\n'));

          // 표준 출력 스트림 상태 확인 및 강제 정리 (실험적)
          if (process.stdout.writable && typeof process.stdout.uncork === 'function') {
            process.stdout.uncork();
          }

          // 입력 프롬프트 활성화를 위한 타이밍 조정
          setTimeout(() => {
            // 표준 입력이 TTY인 경우에만 입력 모드 관련 처리
            if (process.stdin.isTTY) {
              // 입력 스트림 재설정
              process.stdin.resume();
              // 커서 보이기
              process.stdout.write('\u001B[?25h');
            }

            // 1초 후 중복 출력 방지 플래그 초기화 (다음 스트림을 위해)
            setTimeout(() => {
              Logger._hasShownCompletionMessage = false;
            }, 1000);
          }, 100);
        }
      }, 500); // 0.5초 지연

      // 타이머 저장
      Logger._streamCleanupTimers.set(nodeName, cleanupTimer);

      // 모델 종료 이벤트 방출
      Logger._eventManager.emit({
        nodeName,
        eventType: NodeEventType.MODEL_END
      });
    } catch (error) {
      console.error(chalk.red(`[Logger] Error in nodeModelEnd for ${nodeName}:`), error);
      // 오류가 발생해도 안전하게 상태 초기화
      Logger._nodeStreamingStates.delete(nodeName);

      // 활성 노드 목록에서 제거
      const index = Logger._activeStreamingNodes.indexOf(nodeName);
      if (index !== -1) {
        Logger._activeStreamingNodes.splice(index, 1);
      }

      // 락 강제 해제
      Logger._streamingLock = false;
    }
  }

  /**
   * Log node exit
   * 노드 종료 로깅
   * @param nodeName Node name
   * @param status Exit status
   */
  public static nodeExit(nodeName: string, status: string = 'success'): void {
    if (Logger._config.verbose) {
      const statusColor = status === 'success' ? chalk.green : chalk.red;
      console.log(statusColor(`[${nodeName}] Exit (${status})`));
    }

    // 노드 종료 이벤트 방출
    Logger._eventManager.emit({
      nodeName,
      eventType: NodeEventType.END,
      payload: { status }
    });
  }

  /**
   * Log error
   * 오류 로깅
   * @param message Error message
   * @param error Error object
   */
  public static error(message: string, error?: any): void {
    console.error(chalk.red(`[ERROR] ${message}`));
    if (error && Logger._config.debug) {
      console.error(error);
    }

    // 오류 이벤트 방출
    Logger._eventManager.emit({
      nodeName: 'system',
      eventType: NodeEventType.ERROR,
      payload: { message, error }
    });
  }

  /**
   * Log debug message
   * 디버그 메시지 로깅
   * @param message Debug message
   * @param data Optional debug data
   */
  public static debug(message: string, data?: any): void {
    if (Logger._config.debug) {
      console.log(chalk.yellow(`[DEBUG] ${message}`));
      if (data) {
        console.log(data);
      }
    }
  }

  /**
   * Log graph state
   * 그래프 상태 로깅
   * @param label State label
   * @param state State data
   */
  public static graphState(label: string, state: any): void {
    if (Logger._config.graphState) {
      console.log(chalk.green(`[STATE] ${label}:`));
      console.log(state);
    }
  }

  /**
   * Log tool execution
   * 도구 실행 로깅
   * @param tool Tool name
   * @param input Tool input
   */
  public static toolExecution(tool: string, input: any): void {
    if (Logger._config.tools) {
      console.log(chalk.yellow(`[TOOL] Executing: ${tool}`));
      console.log(chalk.yellow(`[TOOL] Input:`), input);
    }
  }

  /**
   * Log tool result
   * 도구 결과 로깅
   * @param tool Tool name
   * @param result Tool result
   * @param success Success flag
   */
  public static toolResult(tool: string, result: any, success: boolean): void {
    if (Logger._config.tools) {
      const statusColor = success ? chalk.green : chalk.red;
      console.log(statusColor(`[TOOL] Result from ${tool}: ${success ? 'Success' : 'Failed'}`));
      console.log(result);
    }
  }

  /**
   * Set node-specific stream visibility
   * 노드별 스트림 가시성 설정
   * @param nodeName Node name
   * @param visible Whether streaming should be visible
   *
   * Generated by Copilot
   */
  public static setNodeStreamVisibility(nodeName: string, visible: boolean): void {
    Logger._config.nodeStreamConfig[nodeName] = visible;
  }

  /**
   * Set multiple node stream visibilities
   * 여러 노드의 스트림 가시성 설정
   * @param config Node visibility configuration
   *
   * Generated by Copilot
   */
  public static setNodeStreamConfig(config: Record<string, boolean>): void {
    Logger._config.nodeStreamConfig = {
      ...Logger._config.nodeStreamConfig,
      ...config
    };
  }

  /**
   * Set always visible nodes
   * 항상 표시할 노드 설정
   * @param nodeNames Array of node names that should always show streaming
   *
   * Generated by Copilot
   */
  public static setAlwaysVisibleNodes(nodeNames: string[]): void {
    if (!Array.isArray(nodeNames)) {
      Logger.debug('Invalid nodeNames provided to setAlwaysVisibleNodes, expected array');
      return;
    }

    // 메모리 설정 업데이트
    Logger._config.alwaysVisibleNodes = nodeNames;

    // 설정 파일도 함께 업데이트
    Logger._configManager.setAlwaysVisibleNodes(nodeNames);
  }

  /**
   * Get current logger configuration
   * 현재 로거 설정 가져오기
   * @returns Current logger configuration
   *
   * Generated by Copilot
   */
  public static getConfig(): Readonly<Required<LoggerConfig>> {
    return { ...Logger._config };
  }

  /**
   * 리소스 정리 및 리스너 제거
   * 애플리케이션 종료 시 호출하여 리소스 정리
   *
   * Generated by Copilot
   */
  public static cleanup(): void {
    // 설정 변경 리스너 제거
    if (Logger._configChangeRemover) {
      Logger._configChangeRemover();
      Logger._configChangeRemover = null;
    }

    // 모든 스트림 강제 종료
    Logger.forceCloseAllStreams();

    // 모든 타이머 제거
    for (const timer of Logger._streamCleanupTimers.values()) {
      clearTimeout(timer);
    }
    Logger._streamCleanupTimers.clear();
  }

  /**
   * 모든 활성 스트림을 강제로 종료합니다.
   * 애플리케이션 종료 시나 스트림 문제 해결을 위한 유틸리티 함수입니다.
   *
   * Generated by Copilot
   */
  public static forceCloseAllStreams(): void {
    try {
      // 이미 모든 스트림이 정리된 경우 추가 처리 방지
      if (Logger._activeStreamingNodes.length === 0 &&
          Logger._nodeStreamingStates.size === 0) {
        return;
      }

      // 모든 활성 스트림 정리
      for (const nodeName of Logger._activeStreamingNodes) {
        console.log(chalk.yellow(`\n[${nodeName} 스트림 강제 종료]\n`));

        // 정리 타이머가 있으면 제거
        if (Logger._streamCleanupTimers.has(nodeName)) {
          clearTimeout(Logger._streamCleanupTimers.get(nodeName));
          Logger._streamCleanupTimers.delete(nodeName);
        }
      }

      // 모든 상태 초기화
      Logger._nodeStreamingStates.clear();
      Logger._activeStreamingNodes = [];
      Logger._streamCleanupTimers.clear();
      Logger._streamingLock = false;

      // 중복 출력을 방지하기 위한 조건 검사
      if (!Logger._hasShownCompletionMessage) {
        // 모든 스트림이 종료되었다는 메시지 출력
        console.log(chalk.cyan('\n--- 모든 AI 응답 스트림이 강제 종료됨 ---\n'));
        Logger._hasShownCompletionMessage = true;

        // 입력 모드 재설정을 위한 지연
        setTimeout(() => {
          Logger._hasShownCompletionMessage = false;
        }, 1000);
      }

      // 표준 출력 스트림 강제 정리 (실험적)
      if (process.stdout.writable) {
        if (typeof process.stdout.uncork === 'function') {
          process.stdout.uncork();
        }
        // flush 메소드는 TypeScript 타입에서 인식되지 않으므로 타입 단언 사용
        const stdoutAny = process.stdout as any;
        if (typeof stdoutAny.flush === 'function') {
          stdoutAny.flush();
        }
      }

      // 입력 프롬프트 활성화
      // 약간 지연된 처리로 출력 버퍼가 모두 처리된 후에 입력 모드 설정
      setTimeout(() => {
        if (process.stdin.isTTY && process.stdout.isTTY) {
          // 터미널이 TTY 모드인 경우에만 처리
          try {
            // 입력 스트림 재설정
            process.stdin.resume();
            // 커서 보이기
            process.stdout.write('\u001B[?25h');
            // 입력 모드가 raw 모드인 경우 토글하여 초기화 (필요 시)
            if (process.stdin.isRaw) {
              process.stdin.setRawMode(false);
              process.stdin.setRawMode(true);
            }
          } catch (e) {
            // stdin/stdout 조작 중 오류는 무시
          }
        }
      }, 200);
    } catch (error) {
      console.error(chalk.red('[Logger] Error while force closing all streams:'), error);
    }
  }
}