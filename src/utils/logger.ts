import chalk from 'chalk';
import { EventManager, NodeEventType } from './events.js';

/**
 * Logger configuration interface
 * 로거 구성 인터페이스
 */
export interface LoggerConfig {
  /** Enable verbose logging */
  verbose?: boolean;
  /** Enable debug logging */
  debug?: boolean;
  /** Enable graph state logging */
  graphState?: boolean;
  /** Enable tool logging */
  tools?: boolean;
  /** Enable AI stream output for all nodes */
  aiStream?: boolean;
  /** Configure node-specific AI stream visibility */
  nodeStreamConfig?: Record<string, boolean>;
  /** Always visible nodes regardless of debug mode */
  alwaysVisibleNodes?: string[];
}

/**
 * Logger class for managing application logs
 * 애플리케이션 로그를 관리하는 로거 클래스
 *
 * Generated by Copilot
 */
export class Logger {
  private static _config: Required<LoggerConfig> = {
    verbose: false,
    debug: false,
    graphState: false,
    tools: true,
    aiStream: false,
    nodeStreamConfig: {},
    alwaysVisibleNodes: ['translateInput', 'executeStep'] // 기본적으로 항상 표시할 노드들
  };

  private static _eventManager = EventManager.getInstance();

  // 마지막 스트리밍 노드를 추적하기 위한 변수
  private static _lastStreamingNode: string | null = null;

  // 마지막 스트림 출력 내용을 추적하기 위한 변수 (중복 출력 방지)
  private static _lastStreamOutput: string = '';

  // 누적된 스트리밍 내용을 저장하기 위한 변수
  private static _accumulatedOutput: string = '';

  /**
   * Configure logger settings
   * 로거 설정 구성
   * @param config Logger configuration
   *
   * Generated by Copilot
   */
  public static configure(config: LoggerConfig): void {
    // 기존 설정 유지하면서 새 설정으로 업데이트
    Logger._config = {
      ...Logger._config,
      ...config,
      // nodeStreamConfig가 제공된 경우 병합
      nodeStreamConfig: {
        ...Logger._config.nodeStreamConfig,
        ...(config.nodeStreamConfig || {})
      },
      // alwaysVisibleNodes가 제공된 경우 덮어쓰기 아니면 기존 값 유지
      alwaysVisibleNodes: config.alwaysVisibleNodes || Logger._config.alwaysVisibleNodes
    };
  }

  /**
   * Check if streaming should be visible for a specific node
   * 특정 노드에 대한 스트리밍 가시성 확인
   * @param nodeName Node name
   * @returns Whether streaming should be visible
   *
   * Generated by Copilot
   */
  private static _isStreamingVisibleForNode(nodeName: string): boolean {
    // 1. 노드별 개별 설정이 있는 경우 우선 적용
    if (nodeName in Logger._config.nodeStreamConfig) {
      return Logger._config.nodeStreamConfig[nodeName];
    }

    // 2. 항상 표시해야 하는 노드 목록에 있는 경우
    if (Logger._config.alwaysVisibleNodes.includes(nodeName)) {
      return true;
    }

    // 3. 그 외에는 글로벌 AI 스트림 설정이나 디버그 모드에 따라 결정
    return Boolean(Logger._config.aiStream || Logger._config.debug);
  }

  /**
   * Log node entry
   * 노드 진입 로깅
   * @param nodeName Node name
   */
  public static nodeEntry(nodeName: string): void {
    if (Logger._config.verbose) {
      console.log(chalk.cyan(`[${nodeName}] Entry`));
    }

    // 노드 시작 이벤트 방출
    Logger._eventManager.emit({
      nodeName,
      eventType: NodeEventType.START
    });
  }

  /**
   * Log node action
   * 노드 액션 로깅
   * @param nodeName Node name
   * @param action Action description
   */
  public static nodeAction(nodeName: string, action: string): void {
    if (Logger._config.verbose) {
      console.log(chalk.blue(`[${nodeName}] ${action}`));
    }
  }

  /**
   * Log node model activity start
   * 노드 모델 활동 시작 로깅
   * @param nodeName Node name
   * @param action Action description
   */
  public static nodeModelStart(nodeName: string, action: string): void {
    if (Logger._config.verbose) {
      console.log(chalk.magenta(`[${nodeName}] ${action}`));
    }

    // 모델 시작 이벤트 방출
    Logger._eventManager.emit({
      nodeName,
      eventType: NodeEventType.MODEL_START,
      payload: { action }
    });
  }

  /**
   * Log node model streaming
   * 노드 모델 스트리밍 로깅
   * @param nodeName Node name
   * @param content Stream content
   *
   * Generated by Copilot
   */
  public static nodeModelStreaming(nodeName: string, content: string): void {
    // 해당 노드에 대한 스트리밍 가시성 확인
    const isVisible = Logger._isStreamingVisibleForNode(nodeName);
    if (isVisible) {
      // 실제 내용이 있는 경우에만 처리
      if (content.trim()) {
        // 모델 스트리밍 이벤트 방출
        Logger._eventManager.emit({
          nodeName,
          eventType: NodeEventType.MODEL_STREAMING,
          payload: { content }
        });
        // 디버그 모드나 특별히 설정된 노드의 경우 내용 출력
        if (Logger._config.debug || Logger._config.aiStream ||
            Logger._config.alwaysVisibleNodes.includes(nodeName)) {
          // 노드가 변경된 경우 새 스트리밍 세션 시작
          if (!Logger._lastStreamingNode || Logger._lastStreamingNode !== nodeName) {
            console.log(chalk.magenta(`\n[${nodeName} 스트림 시작]`));
            Logger._lastStreamingNode = nodeName;
            Logger._accumulatedOutput = '';
          }
          // 누적된 출력에서 새로운 부분만 추출하여 출력
          if (content.length > Logger._accumulatedOutput.length) {
            // 이전에 출력하지 않은 새 부분만 가져옴
            const newContent = content.substring(Logger._accumulatedOutput.length);
            // 새 내용이 있는 경우에만 출력
            if (newContent) {
              process.stdout.write(newContent);
            }
            // 현재 내용을 누적 출력에 저장
            Logger._accumulatedOutput = content;
          }
        }
      }
    }
  }

  /**
   * Log node model activity end
   * 노드 모델 활동 종료 로깅
   * @param nodeName Node name
   *
   * Generated by Copilot
   */
  public static nodeModelEnd(nodeName: string): void {
    // 현재 노드가 스트리밍 중이었던 경우에만 스트림 종료 메시지 출력
    if (Logger._lastStreamingNode === nodeName && Logger._accumulatedOutput) {
      // 스트림 출력이 있었을 때만 종료 메시지 표시
      console.log(chalk.magenta(`\n[${nodeName} 스트림 종료]\n`));

      // 변수 초기화
      Logger._lastStreamingNode = null;
      Logger._accumulatedOutput = '';
    }

    // 모델 종료 이벤트 방출
    Logger._eventManager.emit({
      nodeName,
      eventType: NodeEventType.MODEL_END
    });
  }

  /**
   * Log node exit
   * 노드 종료 로깅
   * @param nodeName Node name
   * @param status Exit status
   */
  public static nodeExit(nodeName: string, status: string = 'success'): void {
    if (Logger._config.verbose) {
      const statusColor = status === 'success' ? chalk.green : chalk.red;
      console.log(statusColor(`[${nodeName}] Exit (${status})`));
    }

    // 노드 종료 이벤트 방출
    Logger._eventManager.emit({
      nodeName,
      eventType: NodeEventType.END,
      payload: { status }
    });
  }

  /**
   * Log error
   * 오류 로깅
   * @param message Error message
   * @param error Error object
   */
  public static error(message: string, error?: any): void {
    console.error(chalk.red(`[ERROR] ${message}`));
    if (error && Logger._config.debug) {
      console.error(error);
    }

    // 오류 이벤트 방출
    Logger._eventManager.emit({
      nodeName: 'system',
      eventType: NodeEventType.ERROR,
      payload: { message, error }
    });
  }

  /**
   * Log debug message
   * 디버그 메시지 로깅
   * @param message Debug message
   * @param data Optional debug data
   */
  public static debug(message: string, data?: any): void {
    if (Logger._config.debug) {
      console.log(chalk.yellow(`[DEBUG] ${message}`));
      if (data) {
        console.log(data);
      }
    }
  }

  /**
   * Log graph state
   * 그래프 상태 로깅
   * @param label State label
   * @param state State data
   */
  public static graphState(label: string, state: any): void {
    if (Logger._config.graphState) {
      console.log(chalk.green(`[STATE] ${label}:`));
      console.log(state);
    }
  }

  /**
   * Log tool execution
   * 도구 실행 로깅
   * @param tool Tool name
   * @param input Tool input
   */
  public static toolExecution(tool: string, input: any): void {
    if (Logger._config.tools) {
      console.log(chalk.yellow(`[TOOL] Executing: ${tool}`));
      console.log(chalk.yellow(`[TOOL] Input:`), input);
    }
  }

  /**
   * Log tool result
   * 도구 결과 로깅
   * @param tool Tool name
   * @param result Tool result
   * @param success Success flag
   */
  public static toolResult(tool: string, result: any, success: boolean): void {
    if (Logger._config.tools) {
      const statusColor = success ? chalk.green : chalk.red;
      console.log(statusColor(`[TOOL] Result from ${tool}: ${success ? 'Success' : 'Failed'}`));
      console.log(result);
    }
  }

  /**
   * Set node-specific stream visibility
   * 노드별 스트림 가시성 설정
   * @param nodeName Node name
   * @param visible Whether streaming should be visible
   *
   * Generated by Copilot
   */
  public static setNodeStreamVisibility(nodeName: string, visible: boolean): void {
    Logger._config.nodeStreamConfig[nodeName] = visible;
  }

  /**
   * Set multiple node stream visibilities
   * 여러 노드의 스트림 가시성 설정
   * @param config Node visibility configuration
   *
   * Generated by Copilot
   */
  public static setNodeStreamConfig(config: Record<string, boolean>): void {
    Logger._config.nodeStreamConfig = {
      ...Logger._config.nodeStreamConfig,
      ...config
    };
  }

  /**
   * Set always visible nodes
   * 항상 표시할 노드 설정
   * @param nodeNames Array of node names that should always show streaming
   *
   * Generated by Copilot
   */
  public static setAlwaysVisibleNodes(nodeNames: string[]): void {
    Logger._config.alwaysVisibleNodes = nodeNames;
  }
}