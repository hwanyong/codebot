import chalk from 'chalk';
import { EventManager, NodeEventType } from './events.js';
import { LOGGER_DEFAULTS } from './constants.js';
import { ConfigManager } from '../config/manager.js';

/**
 * Logger configuration interface
 * 로거 구성 인터페이스
 */
export interface LoggerConfig {
  /** Enable verbose logging */
  verbose?: boolean;
  /** Enable debug logging */
  debug?: boolean;
  /** Enable graph state logging */
  graphState?: boolean;
  /** Enable tool logging */
  tools?: boolean;
  /** Enable AI stream output for all nodes */
  aiStream?: boolean;
  /** Configure node-specific AI stream visibility */
  nodeStreamConfig?: Record<string, boolean>;
  /** Always visible nodes regardless of debug mode */
  alwaysVisibleNodes?: string[];
}

/**
 * Logger class for managing application logs
 * 애플리케이션 로그를 관리하는 로거 클래스
 *
 * Generated by Copilot
 */
export class Logger {
  private static _config: Required<LoggerConfig> = {
    verbose: false,
    debug: false,
    graphState: false,
    tools: true,
    aiStream: false,
    nodeStreamConfig: {},
    alwaysVisibleNodes: LOGGER_DEFAULTS.ALWAYS_VISIBLE_NODES
  };

  private static _eventManager = EventManager.getInstance();
  private static _configManager = ConfigManager.getInstance();
  private static _configChangeRemover: (() => void) | null = null;

  // 마지막 스트리밍 노드를 추적하기 위한 변수
  private static _lastStreamingNode: string | null = null;

  // 마지막 스트림 출력 내용을 추적하기 위한 변수 (중복 출력 방지)
  private static _lastStreamOutput: string = '';

  // 누적된 스트리밍 내용을 저장하기 위한 변수
  private static _accumulatedOutput: string = '';

  /**
   * 정적 초기화 블록
   * 클래스가 로드될 때 설정 변경 리스너 설정
   *
   * Generated by Copilot
   */
  static {
    // 설정 파일 변경 리스너 설정
    Logger._setupConfigChangeListener();
  }

  /**
   * 설정 파일 변경 감지 리스너를 설정합니다.
   *
   * Generated by Copilot
   */
  private static _setupConfigChangeListener(): void {
    // 기존 리스너 제거
    if (Logger._configChangeRemover) {
      Logger._configChangeRemover();
    }

    // 새 리스너 등록
    Logger._configChangeRemover = Logger._configManager.addChangeListener(config => {
      // 설정 파일이 변경되면 로깅 설정 업데이트
      if (config.logging) {
        // 현재 명령줄 옵션은 유지하고 설정 파일의 값만 업데이트
        const currentConfig = { ...Logger._config };

        // aiStream이 명령줄에서 명시적으로 설정되지 않은 경우에만 설정 파일 값 적용
        if (!Logger._commandLineOptions.aiStream && config.logging.defaultAiStream !== undefined) {
          currentConfig.aiStream = config.logging.defaultAiStream;
        }

        // alwaysVisibleNodes 업데이트 (명령줄에서 설정된 값은 없으므로 항상 적용)
        if (config.logging.alwaysVisibleNodes) {
          currentConfig.alwaysVisibleNodes = config.logging.alwaysVisibleNodes;
        }

        // 로깅 설정 업데이트
        Logger.configure(currentConfig, false);

        // 로깅 설정이 업데이트되었음을 디버그 메시지로 표시
        if (Logger._config.debug) {
          console.log(chalk.yellow('[Logger] Configuration updated from config file'));
        }
      }
    });
  }

  /**
   * 명령줄에서 직접 설정된 옵션을 추적하기 위한 객체
   *
   * Generated by Copilot
   */
  private static _commandLineOptions: {
    verbose?: boolean;
    debug?: boolean;
    aiStream?: boolean;
  } = {};

  /**
   * Configure logger settings
   * 로거 설정 구성
   * @param config Logger configuration
   * @param isCommandLine 명령줄에서 직접 호출된 설정인지 여부
   *
   * Generated by Copilot
   */
  public static configure(config: LoggerConfig, isCommandLine: boolean = true): void {
    try {
      // 명령줄에서 직접 설정된 옵션 추적
      if (isCommandLine) {
        if (config.verbose !== undefined) Logger._commandLineOptions.verbose = config.verbose;
        if (config.debug !== undefined) Logger._commandLineOptions.debug = config.debug;
        if (config.aiStream !== undefined) Logger._commandLineOptions.aiStream = config.aiStream;

        // 설정 파일도 함께 업데이트 (alwaysVisibleNodes 및 설정 파일에 저장될 값들)
        if (config.alwaysVisibleNodes) {
          Logger._configManager.setAlwaysVisibleNodes(config.alwaysVisibleNodes);
        }

        // aiStream 값이 명시적으로 설정된 경우 설정 파일도 업데이트
        if (config.aiStream !== undefined) {
          Logger._configManager.setDefaultAiStream(config.aiStream);
        }
      }

      // 기존 설정 유지하면서 새 설정으로 업데이트
      Logger._config = {
        ...Logger._config,
        ...config,
        // nodeStreamConfig가 제공된 경우 병합
        nodeStreamConfig: {
          ...Logger._config.nodeStreamConfig,
          ...(config.nodeStreamConfig || {})
        },
        // alwaysVisibleNodes가 제공된 경우 덮어쓰기 아니면 기존 값 유지
        alwaysVisibleNodes: config.alwaysVisibleNodes || Logger._config.alwaysVisibleNodes
      };

      // 디버그 모드가 활성화된 경우 설정 내용 출력
      if (Logger._config.debug) {
        console.log(chalk.yellow('[Logger] Configuration updated:'), {
          verbose: Logger._config.verbose,
          debug: Logger._config.debug,
          aiStream: Logger._config.aiStream,
          alwaysVisibleNodes: Logger._config.alwaysVisibleNodes.length
        });
      }
    } catch (error) {
      // 설정 중 오류 발생시 안전하게 처리
      console.error(chalk.red('[Logger] Failed to update configuration:'), error);
      // 기본 설정 유지
    }
  }

  /**
   * 초기화: 설정 파일에서 기본 설정을 로드합니다.
   * 아직 Logger가 설정되지 않은 경우 애플리케이션 시작 시 호출해야 합니다.
   *
   * Generated by Copilot
   */
  public static initialize(): void {
    try {
      // 설정 파일에서 로깅 설정 로드
      const loggingConfig = Logger._configManager.getLoggingConfig();

      // 기본 설정 적용 (명령줄 옵션은 아님)
      Logger.configure({
        aiStream: loggingConfig.defaultAiStream,
        alwaysVisibleNodes: loggingConfig.alwaysVisibleNodes
      }, false);

      if (Logger._config.debug) {
        console.log(chalk.yellow('[Logger] Initialized with settings from config file'));
      }
    } catch (error) {
      console.error(chalk.red('[Logger] Failed to initialize from config file:'), error);
    }
  }

  /**
   * Returns whether verbose mode is enabled
   * verbose 모드 활성화 여부 반환
   * @returns Whether verbose mode is enabled
   *
   * Generated by Copilot
   */
  public static isVerbose(): boolean {
    return Logger._config.verbose;
  }

  /**
   * Returns whether debug mode is enabled
   * debug 모드 활성화 여부 반환
   * @returns Whether debug mode is enabled
   *
   * Generated by Copilot
   */
  public static isDebug(): boolean {
    return Logger._config.debug;
  }

  /**
   * Returns whether AI streaming is enabled for a specific node
   * 특정 노드에 대한 AI 스트리밍 활성화 여부 반환
   * @param nodeName Node name
   * @returns Whether AI streaming is enabled for the node
   *
   * Generated by Copilot
   */
  public static isStreamEnabled(nodeName: string): boolean {
    return Logger._isStreamingVisibleForNode(nodeName);
  }

  /**
   * Check if streaming should be visible for a specific node
   * 특정 노드에 대한 스트리밍 가시성 확인
   * @param nodeName Node name
   * @returns Whether streaming should be visible
   *
   * Generated by Copilot
   */
  private static _isStreamingVisibleForNode(nodeName: string): boolean {
    try {
      // 노드가 유효하지 않으면 기본값 반환
      if (!nodeName) {
        return Boolean(Logger._config.aiStream || Logger._config.debug);
      }

      // 1. 노드별 개별 설정이 있는 경우 우선 적용
      if (nodeName in Logger._config.nodeStreamConfig) {
        return Logger._config.nodeStreamConfig[nodeName];
      }

      // 2. 항상 표시해야 하는 노드 목록에 있는 경우
      if (Logger._config.alwaysVisibleNodes.includes(nodeName)) {
        return true;
      }

      // 3. 그 외에는 글로벌 AI 스트림 설정이나 디버그 모드에 따라 결정
      return Boolean(Logger._config.aiStream || Logger._config.debug);
    } catch (error) {
      // 오류 발생 시 안전하게 기본값 반환
      console.error(chalk.red(`[Logger] Error checking stream visibility for node ${nodeName}:`), error);
      // 기본적으로 디버그 모드일 때만 보이게 설정
      return Logger._config.debug;
    }
  }

  /**
   * Log node entry
   * 노드 진입 로깅
   * @param nodeName Node name
   */
  public static nodeEntry(nodeName: string): void {
    if (Logger._config.verbose) {
      console.log(chalk.cyan(`[${nodeName}] Entry`));
    }

    // 노드 시작 이벤트 방출
    Logger._eventManager.emit({
      nodeName,
      eventType: NodeEventType.START
    });
  }

  /**
   * Log node action
   * 노드 액션 로깅
   * @param nodeName Node name
   * @param action Action description
   */
  public static nodeAction(nodeName: string, action: string): void {
    if (Logger._config.verbose) {
      console.log(chalk.blue(`[${nodeName}] ${action}`));
    }
  }

  /**
   * Log node model activity start
   * 노드 모델 활동 시작 로깅
   * @param nodeName Node name
   * @param action Action description
   */
  public static nodeModelStart(nodeName: string, action: string): void {
    if (Logger._config.verbose) {
      console.log(chalk.magenta(`[${nodeName}] ${action}`));
    }

    // 모델 시작 이벤트 방출
    Logger._eventManager.emit({
      nodeName,
      eventType: NodeEventType.MODEL_START,
      payload: { action }
    });
  }

  /**
   * Log node model streaming
   * 노드 모델 스트리밍 로깅
   * @param nodeName Node name
   * @param content Stream content
   *
   * Generated by Copilot
   */
  public static nodeModelStreaming(nodeName: string, content: string): void {
    try {
      // 해당 노드에 대한 스트리밍 가시성 확인
      const isVisible = Logger._isStreamingVisibleForNode(nodeName);
      if (isVisible) {
        // 실제 내용이 있는 경우에만 처리
        if (content.trim()) {
          // 모델 스트리밍 이벤트 방출
          Logger._eventManager.emit({
            nodeName,
            eventType: NodeEventType.MODEL_STREAMING,
            payload: { content }
          });
          // 디버그 모드나 특별히 설정된 노드의 경우 내용 출력
          if (Logger._config.debug || Logger._config.aiStream ||
              Logger._config.alwaysVisibleNodes.includes(nodeName)) {
            // 노드가 변경된 경우 새 스트리밍 세션 시작
            if (!Logger._lastStreamingNode || Logger._lastStreamingNode !== nodeName) {
              console.log(chalk.magenta(`\n[${nodeName} 스트림 시작]`));
              Logger._lastStreamingNode = nodeName;
              Logger._accumulatedOutput = '';
            }
            // 누적된 출력에서 새로운 부분만 추출하여 출력
            if (content.length > Logger._accumulatedOutput.length) {
              // 이전에 출력하지 않은 새 부분만 가져옴
              const newContent = content.substring(Logger._accumulatedOutput.length);
              // 새 내용이 있는 경우에만 출력
              if (newContent) {
                process.stdout.write(newContent);
              }
              // 현재 내용을 누적 출력에 저장
              Logger._accumulatedOutput = content;
            }
          }
        }
      }
    } catch (error) {
      // 스트림 출력 처리 중 오류가 발생해도 애플리케이션이 중단되지 않도록 처리
      console.error(chalk.red(`[Logger] Error in nodeModelStreaming for ${nodeName}:`), error);
    }
  }

  /**
   * Log node model activity end
   * 노드 모델 활동 종료 로깅
   * @param nodeName Node name
   *
   * Generated by Copilot
   */
  public static nodeModelEnd(nodeName: string): void {
    try {
      // 현재 노드가 스트리밍 중이었던 경우에만 스트림 종료 메시지 출력
      if (Logger._lastStreamingNode === nodeName && Logger._accumulatedOutput) {
        // 스트림 출력이 있었을 때만 종료 메시지 표시
        console.log(chalk.magenta(`\n[${nodeName} 스트림 종료]\n`));

        // 변수 초기화
        Logger._lastStreamingNode = null;
        Logger._accumulatedOutput = '';
      }

      // 모델 종료 이벤트 방출
      Logger._eventManager.emit({
        nodeName,
        eventType: NodeEventType.MODEL_END
      });
    } catch (error) {
      console.error(chalk.red(`[Logger] Error in nodeModelEnd for ${nodeName}:`), error);
      // 오류가 발생해도 안전하게 상태 초기화
      Logger._lastStreamingNode = null;
      Logger._accumulatedOutput = '';
    }
  }

  /**
   * Log node exit
   * 노드 종료 로깅
   * @param nodeName Node name
   * @param status Exit status
   */
  public static nodeExit(nodeName: string, status: string = 'success'): void {
    if (Logger._config.verbose) {
      const statusColor = status === 'success' ? chalk.green : chalk.red;
      console.log(statusColor(`[${nodeName}] Exit (${status})`));
    }

    // 노드 종료 이벤트 방출
    Logger._eventManager.emit({
      nodeName,
      eventType: NodeEventType.END,
      payload: { status }
    });
  }

  /**
   * Log error
   * 오류 로깅
   * @param message Error message
   * @param error Error object
   */
  public static error(message: string, error?: any): void {
    console.error(chalk.red(`[ERROR] ${message}`));
    if (error && Logger._config.debug) {
      console.error(error);
    }

    // 오류 이벤트 방출
    Logger._eventManager.emit({
      nodeName: 'system',
      eventType: NodeEventType.ERROR,
      payload: { message, error }
    });
  }

  /**
   * Log debug message
   * 디버그 메시지 로깅
   * @param message Debug message
   * @param data Optional debug data
   */
  public static debug(message: string, data?: any): void {
    if (Logger._config.debug) {
      console.log(chalk.yellow(`[DEBUG] ${message}`));
      if (data) {
        console.log(data);
      }
    }
  }

  /**
   * Log graph state
   * 그래프 상태 로깅
   * @param label State label
   * @param state State data
   */
  public static graphState(label: string, state: any): void {
    if (Logger._config.graphState) {
      console.log(chalk.green(`[STATE] ${label}:`));
      console.log(state);
    }
  }

  /**
   * Log tool execution
   * 도구 실행 로깅
   * @param tool Tool name
   * @param input Tool input
   */
  public static toolExecution(tool: string, input: any): void {
    if (Logger._config.tools) {
      console.log(chalk.yellow(`[TOOL] Executing: ${tool}`));
      console.log(chalk.yellow(`[TOOL] Input:`), input);
    }
  }

  /**
   * Log tool result
   * 도구 결과 로깅
   * @param tool Tool name
   * @param result Tool result
   * @param success Success flag
   */
  public static toolResult(tool: string, result: any, success: boolean): void {
    if (Logger._config.tools) {
      const statusColor = success ? chalk.green : chalk.red;
      console.log(statusColor(`[TOOL] Result from ${tool}: ${success ? 'Success' : 'Failed'}`));
      console.log(result);
    }
  }

  /**
   * Set node-specific stream visibility
   * 노드별 스트림 가시성 설정
   * @param nodeName Node name
   * @param visible Whether streaming should be visible
   *
   * Generated by Copilot
   */
  public static setNodeStreamVisibility(nodeName: string, visible: boolean): void {
    Logger._config.nodeStreamConfig[nodeName] = visible;
  }

  /**
   * Set multiple node stream visibilities
   * 여러 노드의 스트림 가시성 설정
   * @param config Node visibility configuration
   *
   * Generated by Copilot
   */
  public static setNodeStreamConfig(config: Record<string, boolean>): void {
    Logger._config.nodeStreamConfig = {
      ...Logger._config.nodeStreamConfig,
      ...config
    };
  }

  /**
   * Set always visible nodes
   * 항상 표시할 노드 설정
   * @param nodeNames Array of node names that should always show streaming
   *
   * Generated by Copilot
   */
  public static setAlwaysVisibleNodes(nodeNames: string[]): void {
    if (!Array.isArray(nodeNames)) {
      Logger.debug('Invalid nodeNames provided to setAlwaysVisibleNodes, expected array');
      return;
    }

    // 메모리 설정 업데이트
    Logger._config.alwaysVisibleNodes = nodeNames;

    // 설정 파일도 함께 업데이트
    Logger._configManager.setAlwaysVisibleNodes(nodeNames);
  }

  /**
   * Get current logger configuration
   * 현재 로거 설정 가져오기
   * @returns Current logger configuration
   *
   * Generated by Copilot
   */
  public static getConfig(): Readonly<Required<LoggerConfig>> {
    return { ...Logger._config };
  }

  /**
   * 리소스 정리 및 리스너 제거
   * 애플리케이션 종료 시 호출하여 리소스 정리
   *
   * Generated by Copilot
   */
  public static cleanup(): void {
    if (Logger._configChangeRemover) {
      Logger._configChangeRemover();
      Logger._configChangeRemover = null;
    }
  }
}