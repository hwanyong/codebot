/**
 * 파일 시스템 도구 테스트 케이스
 * File System Tool Test Cases
 *
 * 파일 시스템 관련 도구의 기능을 테스트합니다.
 * Tests functionality of file system related tools.
 *
 * Generated by Copilot
 */

import { TestSuite } from '../../runner.js';
import assert from 'assert';
import path from 'path';
import fs from 'fs/promises';
import os from 'os';

// 테스트에 필요한 도구 가져오기
import { ListFilesTool } from '../../../tools/fileSystem/listFiles.js';
import { ReadFileTool } from '../../../tools/fileSystem/readFile.js';
import { WriteFileTool } from '../../../tools/fileSystem/writeFile.js';

// 도구 인스턴스 생성
const listFilesTool = new ListFilesTool();
const readFileTool = new ReadFileTool();
const writeFileTool = new WriteFileTool();

/**
 * 테스트용 임시 디렉토리 생성
 * @returns 임시 디렉토리 경로
 */
async function createTempTestDir(): Promise<string> {
  const tempDir = path.join(os.tmpdir(), `codebot-test-${Date.now()}`);
  await fs.mkdir(tempDir, { recursive: true });

  // 테스트 파일 생성
  await fs.writeFile(path.join(tempDir, 'test1.txt'), 'Test file 1 content');
  await fs.writeFile(path.join(tempDir, 'test2.txt'), 'Test file 2 content');

  // 테스트 하위 디렉토리 생성
  const subDir = path.join(tempDir, 'subdir');
  await fs.mkdir(subDir, { recursive: true });
  await fs.writeFile(path.join(subDir, 'test3.txt'), 'Test file 3 content');

  return tempDir;
}

/**
 * 테스트 디렉토리 삭제
 * @param tempDir 임시 디렉토리 경로
 */
async function cleanupTempDir(tempDir: string): Promise<void> {
  try {
    await fs.rm(tempDir, { recursive: true, force: true });
  } catch (error) {
    console.error(`임시 디렉토리 삭제 오류: ${error}`);
  }
}

/**
 * 파일 시스템 도구 테스트 스위트
 */
export const fileSystemTests: TestSuite = {
  /**
   * ListFilesTool 기본 기능 테스트
   */
  async 'ListFilesTool - 기본 디렉토리 콘텐츠 나열'() {
    // 임시 테스트 디렉토리 생성
    const tempDir = await createTempTestDir();

    try {
      // 목록 조회 (비재귀적)
      const result1 = await listFilesTool.execute({
        path: tempDir,
        patterns: []
      });

      // 재귀적 목록 조회
      const result2 = await listFilesTool.execute({
        path: tempDir,
        patterns: [],
        recursive: true
      });

      // 검증
      assert.strictEqual(result1.success, true, '목록 조회가 성공해야 합니다.');
      assert.strictEqual(result1.files.length, 3, '최상위 디렉토리에는 3개의 항목이 있어야 합니다.');
      assert.strictEqual(result2.success, true, '재귀적 목록 조회가 성공해야 합니다.');
      assert.strictEqual(result2.files.length, 4, '전체 디렉토리에는 4개의 항목이 있어야 합니다.');

    } finally {
      // 테스트 후 정리
      await cleanupTempDir(tempDir);
    }
  },

  /**
   * ReadFileTool 테스트
   */
  async 'ReadFileTool - 파일 읽기'() {
    // 임시 테스트 디렉토리 생성
    const tempDir = await createTempTestDir();

    try {
      const testFilePath = path.join(tempDir, 'test1.txt');

      // 파일 읽기
      const result = await readFileTool.execute({ path: testFilePath });

      // 검증
      assert.strictEqual(result.success, true, '파일 읽기가 성공해야 합니다.');
      assert.strictEqual(result.content, 'Test file 1 content', '파일 내용이 일치해야 합니다.');

    } finally {
      // 테스트 후 정리
      await cleanupTempDir(tempDir);
    }
  },

  /**
   * WriteFileTool 테스트
   */
  async 'WriteFileTool - 파일 쓰기'() {
    // 임시 테스트 디렉토리 생성
    const tempDir = await createTempTestDir();

    try {
      const testFilePath = path.join(tempDir, 'write-test.txt');
      const testContent = 'This is a test content for writing.';

      // 파일 쓰기
      const writeResult = await writeFileTool.execute({
        path: testFilePath,
        content: testContent
      });

      // 검증 1: 쓰기 결과
      assert.strictEqual(writeResult.success, true, '파일 쓰기가 성공해야 합니다.');

      // 검증 2: 파일이 실제로 생성되었는지 확인
      const fileExists = await fs.access(testFilePath)
        .then(() => true)
        .catch(() => false);
      assert.strictEqual(fileExists, true, '파일이 생성되어야 합니다.');

      // 검증 3: 파일 내용이 올바른지 확인
      const readResult = await readFileTool.execute({ path: testFilePath });
      assert.strictEqual(readResult.content, testContent, '쓰여진 내용이 일치해야 합니다.');

    } finally {
      // 테스트 후 정리
      await cleanupTempDir(tempDir);
    }
  },

  /**
   * 존재하지 않는 파일/디렉토리 오류 처리 테스트
   */
  async '파일 시스템 도구 - 오류 처리'() {
    // 존재하지 않는 경로
    const nonExistentPath = path.join(os.tmpdir(), `non-existent-${Date.now()}`);

    try {
      // ListFilesTool로 존재하지 않는 디렉토리 조회
      const listResult = await listFilesTool.execute({
        path: nonExistentPath,
        patterns: []
      });
      assert.strictEqual(listResult.success, false, '존재하지 않는 디렉토리 조회는 실패해야 합니다.');

      // ReadFileTool로 존재하지 않는 파일 읽기
      const nonExistentFilePath = path.join(nonExistentPath, 'non-existent.txt');
      const readResult = await readFileTool.execute({ path: nonExistentFilePath });
      assert.strictEqual(readResult.success, false, '존재하지 않는 파일 읽기는 실패해야 합니다.');

      // WriteFileTool로 존재하지 않는 디렉토리에 파일 쓰기 (디렉토리 자동 생성 기능 테스트)
      const writeFilePath = path.join(nonExistentPath, 'auto-created-dir', 'test-file.txt');
      const writeResult = await writeFileTool.execute({
        path: writeFilePath,
        content: 'Test content'
      });

      // WriteFileTool은 디렉토리를 자동 생성하므로 성공해야 함
      assert.strictEqual(writeResult.success, true, '존재하지 않는 디렉토리에 파일 쓰기가 성공해야 합니다.');

      // 디렉토리가 실제로 생성되었는지 확인
      const dirExists = await fs.access(path.dirname(writeFilePath))
        .then(() => true)
        .catch(() => false);
      assert.strictEqual(dirExists, true, '디렉토리가 자동으로 생성되어야 합니다.');

      // 파일이 실제로 생성되었는지 확인
      const fileExists = await fs.access(writeFilePath)
        .then(() => true)
        .catch(() => false);
      assert.strictEqual(fileExists, true, '파일이 생성되어야 합니다.');

    } finally {
      // 테스트 중 생성된 파일 및 디렉토리 정리
      try {
        await fs.rm(nonExistentPath, { recursive: true, force: true });
      } catch (error) {
        // 이미 존재하지 않는 경우 무시
      }
    }
  }
};