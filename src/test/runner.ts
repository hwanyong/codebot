/**
 * 테스트 러너 클래스
 * Test Runner Class
 *
 * 도구 테스트를 실행하고 결과를 관리합니다.
 * Runs tool tests and manages results.
 *
 * Generated by Copilot
 */

import { I18n } from '../config/i18n.js';
import chalk from 'chalk';

/**
 * 테스트 결과 인터페이스
 */
export interface TestResult {
  name: string;
  passed: boolean;
  message?: string;
  error?: Error;
  duration: number;
}

/**
 * 테스트 함수 타입
 */
export type TestFunction = () => Promise<void>;

/**
 * 테스트 스위트 인터페이스
 */
export interface TestSuite {
  [testName: string]: TestFunction;
}

/**
 * 테스트 카테고리 인터페이스
 */
export interface TestCategory {
  name: string;
  description: string;
  tests: TestSuite;
}

/**
 * 도구 테스트를 실행하는 테스트 러너 클래스
 */
export class TestRunner {
  private _categories: Map<string, TestCategory> = new Map();
  private _i18n: I18n;

  /**
   * TestRunner 클래스 생성자
   */
  constructor() {
    this._i18n = I18n.getInstance();
  }

  /**
   * 테스트 카테고리를 등록합니다.
   * @param name 카테고리 이름
   * @param description 카테고리 설명
   * @param tests 테스트 스위트
   */
  public registerTestCategory(name: string, description: string, tests: TestSuite): void {
    // 이미 존재하는 카테고리인지 확인
    if (this._categories.has(name)) {
      throw new Error(this._i18n.t('test_duplicate_category', name));
    }

    this._categories.set(name, {
      name,
      description,
      tests
    });
  }

  /**
   * 등록된 테스트 카테고리 목록을 반환합니다.
   * @returns 테스트 카테고리 목록
   */
  public getCategories(): TestCategory[] {
    return Array.from(this._categories.values());
  }

  /**
   * 특정 카테고리의 테스트를 실행합니다.
   * @param categoryName 카테고리 이름
   * @param testName 특정 테스트 이름 (선택적)
   * @returns 테스트 결과
   */
  public async runCategory(categoryName: string, testName?: string): Promise<TestResult[]> {
    const category = this._categories.get(categoryName);

    if (!category) {
      throw new Error(this._i18n.t('test_category_not_found', categoryName));
    }

    console.log(chalk.cyan(this._i18n.t('test_running_category', categoryName)));

    const results: TestResult[] = [];
    const tests = category.tests;

    if (testName) {
      // 특정 테스트만 실행
      const testFn = tests[testName];
      if (!testFn) {
        throw new Error(this._i18n.t('test_not_found', testName, categoryName));
      }

      console.log(chalk.yellow(`- ${testName}`));
      const result = await this._runTest(testName, testFn);
      results.push(result);

      // 결과 출력
      this._printTestResult(result);
    } else {
      // 카테고리의 모든 테스트 실행
      for (const [name, testFn] of Object.entries(tests)) {
        console.log(chalk.yellow(`- ${name}`));
        const result = await this._runTest(name, testFn);
        results.push(result);

        // 결과 출력
        this._printTestResult(result);
      }
    }

    // 요약 출력
    this._printSummary(results);

    return results;
  }

  /**
   * 모든 카테고리의 테스트를 실행합니다.
   * @param filterCategory 특정 카테고리만 실행 (선택적)
   * @returns 카테고리별 테스트 결과
   */
  public async runAll(filterCategory?: string): Promise<Record<string, TestResult[]>> {
    console.log(chalk.cyan(this._i18n.t('test_running_all')));

    const allResults: Record<string, TestResult[]> = {};

    // 필터링된 카테고리 또는 모든 카테고리 가져오기
    const categories = filterCategory
      ? Array.from(this._categories.entries()).filter(([name]) => name === filterCategory)
      : Array.from(this._categories.entries());

    for (const [name, _] of categories) {
      console.log(chalk.magenta(`\n${this._i18n.t('test_category')}: ${name}`));
      const results = await this.runCategory(name);
      allResults[name] = results;
    }

    return allResults;
  }

  /**
   * 테스트 결과를 출력합니다.
   * @param result 테스트 결과
   * @private
   */
  private _printTestResult(result: TestResult): void {
    if (result.passed) {
      console.log(chalk.green(`  ✓ ${result.name} (${result.duration}ms) - ${this._i18n.t('test_passed')}`));
    } else {
      console.log(chalk.red(`  ✗ ${result.name} (${result.duration}ms) - ${this._i18n.t('test_failed')}`));
      if (result.message) {
        console.log(chalk.red(`    ${result.message}`));
      }
      if (result.error && result.error.stack) {
        console.log(chalk.gray(`    ${result.error.stack}`));
      }
    }
  }

  /**
   * 테스트 요약을 출력합니다.
   * @param results 테스트 결과 배열
   * @private
   */
  private _printSummary(results: TestResult[]): void {
    const total = results.length;
    const passed = results.filter(r => r.passed).length;
    const failed = total - passed;

    const summaryText = this._i18n.t('test_summary', total, passed, failed);

    if (failed > 0) {
      console.log(chalk.red(`\n${summaryText}`));
    } else {
      console.log(chalk.green(`\n${summaryText}`));
    }
  }

  /**
   * 단일 테스트를 실행합니다.
   * @param name 테스트 이름
   * @param testFn 테스트 함수
   * @returns 테스트 결과
   * @private
   */
  private async _runTest(name: string, testFn: TestFunction): Promise<TestResult> {
    const result: TestResult = {
      name,
      passed: false,
      duration: 0
    };

    const startTime = Date.now();

    try {
      await testFn();
      result.passed = true;
    } catch (error) {
      result.passed = false;
      result.error = error instanceof Error ? error : new Error(String(error));
      result.message = error instanceof Error ? error.message : String(error);
    }

    const endTime = Date.now();
    result.duration = endTime - startTime;

    return result;
  }
}