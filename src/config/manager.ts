import fs from 'fs';
import path from 'path';
import { getConfigDir, getConfigFilePath, getEnvFilePath } from './paths.js';
import readline from 'readline';
import chalk from 'chalk';
import dotenv from 'dotenv';
import { Language } from './i18n.js';
import { LOGGER_DEFAULTS } from '../utils/constants.js';

/**
 * Provider 타입
 */
export type Provider = {
  name: string;
  type: 'openai' | 'ollama' | 'anthropic' | 'custom';
  apiKey?: string;
  baseUrl?: string;
  models?: string[];
  isDefault?: boolean;
};

/**
 * 로깅 설정 인터페이스
 * Logging configuration interface
 *
 * Generated by Copilot
 */
export interface LoggingConfig {
  /** 기본 AI 스트림 활성화 여부 */
  defaultAiStream?: boolean;
  /** 항상 표시할 노드 목록 */
  alwaysVisibleNodes?: string[];
}

/**
 * 설정 인터페이스
 */
export interface Config {
  providers: Provider[];
  defaultProvider?: string;
  language: Language;
  lastUsed?: {
    provider: string;
    model: string;
  };
  /** 로깅 관련 설정 */
  logging?: LoggingConfig;
}

/**
 * 기본 설정
 */
const DEFAULT_CONFIG: Config = {
  providers: [],
  defaultProvider: undefined,
  language: 'en', // 기본 언어는 영어
  logging: {
    defaultAiStream: false,
    alwaysVisibleNodes: LOGGER_DEFAULTS.ALWAYS_VISIBLE_NODES
  }
};

/**
 * 설정 변경 이벤트 리스너 타입
 * Configuration change event listener type
 *
 * Generated by Copilot
 */
type ConfigChangeListener = (config: Config) => void;

/**
 * 설정 관리자 클래스
 */
export class ConfigManager {
  private config: Config;
  private configDir: string;
  private configFilePath: string;
  private envFilePath: string;
  private watcher: fs.FSWatcher | null = null;
  private changeListeners: ConfigChangeListener[] = [];
  private static instance: ConfigManager | null = null;

  /**
   * 설정 관리자 인스턴스를 가져옵니다.
   * 싱글톤 패턴을 사용하여 항상 동일한 인스턴스를 반환합니다.
   *
   * @returns ConfigManager 인스턴스
   *
   * Generated by Copilot
   */
  public static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }

  /**
   * 설정 관리자 생성자
   */
  constructor() {
    this.configDir = getConfigDir();
    this.configFilePath = getConfigFilePath();
    this.envFilePath = getEnvFilePath();
    this.config = { ...DEFAULT_CONFIG };
    this.ensureConfigDir();

    // 단일 인스턴스만 파일 변경 감지 설정
    if (!ConfigManager.instance) {
      ConfigManager.instance = this;
      this.setupConfigFileWatcher();
    }
  }

  /**
   * 설정 디렉토리가 존재하는지 확인하고, 없으면 생성합니다.
   */
  private ensureConfigDir(): void {
    if (!fs.existsSync(this.configDir)) {
      fs.mkdirSync(this.configDir, { recursive: true });
    }
  }

  /**
   * 설정 파일 변경 감지를 설정합니다.
   * Sets up configuration file change detection.
   *
   * Generated by Copilot
   */
  private setupConfigFileWatcher(): void {
    try {
      // 기존 watcher가 있으면 닫기
      if (this.watcher) {
        this.watcher.close();
      }

      // 파일이 없으면 빈 설정 파일 생성
      if (!fs.existsSync(this.configFilePath)) {
        this.saveConfig();
      }

      // 설정 파일 변경 감지 설정
      this.watcher = fs.watch(this.configFilePath, (eventType) => {
        if (eventType === 'change') {
          // 파일이 변경되면 설정 다시 로드 및 리스너에 알림
          this.reloadConfig();
        }
      });
    } catch (error) {
      console.error(chalk.red(`[ConfigManager] Failed to setup file watcher: ${error instanceof Error ? error.message : String(error)}`));
    }
  }

  /**
   * 설정 변경 리스너를 추가합니다.
   * 설정이 변경될 때마다 등록된 모든 리스너에 알림이 전송됩니다.
   *
   * @param listener 설정 변경 알림을 받을 리스너 함수
   * @returns 리스너 제거 함수
   *
   * Generated by Copilot
   */
  public addChangeListener(listener: ConfigChangeListener): () => void {
    this.changeListeners.push(listener);

    // 리스너 제거 함수 반환
    return () => {
      const index = this.changeListeners.indexOf(listener);
      if (index !== -1) {
        this.changeListeners.splice(index, 1);
      }
    };
  }

  /**
   * 모든 리스너에게 설정 변경을 알립니다.
   *
   * Generated by Copilot
   */
  private notifyListeners(): void {
    const configCopy = { ...this.config };

    // 비동기적으로 모든 리스너에게 알림
    setTimeout(() => {
      this.changeListeners.forEach(listener => {
        try {
          listener(configCopy);
        } catch (error) {
          console.error(chalk.red(`[ConfigManager] Error in config change listener: ${error instanceof Error ? error.message : String(error)}`));
        }
      });
    }, 0);
  }

  /**
   * 설정 파일이 존재하는지 확인합니다.
   */
  public configExists(): boolean {
    return fs.existsSync(this.configFilePath);
  }

  /**
   * 설정을 다시 로드합니다.
   * 파일 시스템에서 최신 설정을 읽어오고 리스너에게 변경을 알립니다.
   *
   * @returns 로드된 설정
   *
   * Generated by Copilot
   */
  public reloadConfig(): Config {
    const previousConfig = { ...this.config };
    const newConfig = this.loadConfig();

    // 내용이 변경된 경우에만 리스너에게 알림
    if (JSON.stringify(previousConfig) !== JSON.stringify(newConfig)) {
      this.notifyListeners();
    }

    return newConfig;
  }

  /**
   * 설정 파일을 로드합니다.
   */
  public loadConfig(): Config {
    try {
      if (this.configExists()) {
        const configData = fs.readFileSync(this.configFilePath, 'utf-8');
        const loadedConfig = JSON.parse(configData);

        // 로드된 설정과 기본 설정을 병합
        this.config = this.mergeWithDefaults(loadedConfig);
      } else {
        // 설정 파일이 없으면 기본 설정 사용
        this.config = { ...DEFAULT_CONFIG };
      }
      return this.config;
    } catch (error) {
      console.error(chalk.red(`[ConfigManager] Failed to load config: ${error instanceof Error ? error.message : String(error)}`));
      return { ...DEFAULT_CONFIG };
    }
  }

  /**
   * 로드된 설정을 기본 설정과 병합합니다.
   * @param loadedConfig 로드된 설정
   * @returns 병합된 설정
   *
   * Generated by Copilot
   */
  private mergeWithDefaults(loadedConfig: Partial<Config>): Config {
    // 기본 설정의 깊은 복사본 생성
    const result: Config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));

    // 로드된 설정의 최상위 필드 병합
    if (loadedConfig.providers) result.providers = loadedConfig.providers;
    if (loadedConfig.defaultProvider) result.defaultProvider = loadedConfig.defaultProvider;
    if (loadedConfig.language) result.language = loadedConfig.language;
    if (loadedConfig.lastUsed) result.lastUsed = loadedConfig.lastUsed;

    // 로깅 설정 병합
    if (loadedConfig.logging) {
      result.logging = result.logging || {};

      if (loadedConfig.logging.defaultAiStream !== undefined) {
        result.logging.defaultAiStream = loadedConfig.logging.defaultAiStream;
      }

      if (loadedConfig.logging.alwaysVisibleNodes) {
        result.logging.alwaysVisibleNodes = loadedConfig.logging.alwaysVisibleNodes;
      }
    }

    return result;
  }

  /**
   * 설정 파일을 저장합니다.
   */
  public saveConfig(): void {
    try {
      // 설정 디렉토리 확인
      this.ensureConfigDir();

      // 설정을 JSON 형식으로 저장
      fs.writeFileSync(this.configFilePath, JSON.stringify(this.config, null, 2));

      // 설정 변경 알림은 watcher에 의해 자동으로 처리됨
    } catch (error) {
      console.error(chalk.red(`[ConfigManager] Failed to save config: ${error instanceof Error ? error.message : String(error)}`));
    }
  }

  /**
   * 환경 변수 파일을 생성합니다.
   */
  public saveEnvFile(): void {
    try {
      let envContent = '';

      // 모든 provider의 API 키를 환경 변수로 저장
      for (const provider of this.config.providers) {
        if (provider.apiKey) {
          switch (provider.type) {
            case 'openai':
              envContent += `OPENAI_API_KEY=${provider.apiKey}\n`;
              break;
            case 'anthropic':
              envContent += `ANTHROPIC_API_KEY=${provider.apiKey}\n`;
              break;
            case 'ollama':
              if (provider.baseUrl) {
                envContent += `OLLAMA_BASE_URL=${provider.baseUrl}\n`;
              }
              break;
            case 'custom':
              if (provider.name && provider.apiKey) {
                const envName = `${provider.name.toUpperCase()}_API_KEY`;
                envContent += `${envName}=${provider.apiKey}\n`;
              }
              if (provider.baseUrl) {
                const envName = `${provider.name.toUpperCase()}_BASE_URL`;
                envContent += `${envName}=${provider.baseUrl}\n`;
              }
              break;
          }
        }
      }

      fs.writeFileSync(this.envFilePath, envContent);
    } catch (error) {
      console.error(chalk.red(`[ConfigManager] Failed to save env file: ${error instanceof Error ? error.message : String(error)}`));
    }
  }

  /**
   * 환경 변수를 로드합니다.
   */
  public loadEnv(): void {
    if (fs.existsSync(this.envFilePath)) {
      dotenv.config({ path: this.envFilePath });
    }
  }

  /**
   * Provider를 추가합니다.
   */
  public addProvider(provider: Provider): void {
    // 이미 존재하는 provider인지 확인
    const existingIndex = this.config.providers.findIndex(p => p.name === provider.name);

    if (existingIndex !== -1) {
      // 기존 provider 업데이트
      this.config.providers[existingIndex] = provider;
    } else {
      // 새 provider 추가
      this.config.providers.push(provider);
    }

    // 첫 번째 provider이거나 isDefault가 true인 경우 기본값으로 설정
    if (this.config.providers.length === 1 || provider.isDefault) {
      this.config.defaultProvider = provider.name;

      // 다른 provider의 isDefault를 false로 설정
      if (provider.isDefault) {
        this.config.providers.forEach(p => {
          if (p.name !== provider.name) {
            p.isDefault = false;
          }
        });
      }
    }

    this.saveConfig();
    this.saveEnvFile();
  }

  /**
   * Provider를 제거합니다.
   */
  public removeProvider(providerName: string): void {
    const index = this.config.providers.findIndex(p => p.name === providerName);

    if (index !== -1) {
      const removedProvider = this.config.providers.splice(index, 1)[0];

      // 제거된 provider가 기본값이었다면 다른 provider를 기본값으로 설정
      if (this.config.defaultProvider === removedProvider.name && this.config.providers.length > 0) {
        this.config.defaultProvider = this.config.providers[0].name;
        this.config.providers[0].isDefault = true;
      } else if (this.config.providers.length === 0) {
        this.config.defaultProvider = undefined;
      }

      this.saveConfig();
      this.saveEnvFile();
    }
  }

  /**
   * 기본 Provider를 설정합니다.
   */
  public setDefaultProvider(providerName: string): void {
    const provider = this.config.providers.find(p => p.name === providerName);

    if (provider) {
      this.config.defaultProvider = providerName;

      // 모든 provider의 isDefault를 false로 설정
      this.config.providers.forEach(p => {
        p.isDefault = p.name === providerName;
      });

      this.saveConfig();
    }
  }

  /**
   * 기본 Provider를 가져옵니다.
   */
  public getDefaultProvider(): Provider | undefined {
    if (!this.config.defaultProvider) {
      return undefined;
    }

    return this.config.providers.find(p => p.name === this.config.defaultProvider);
  }

  /**
   * 마지막으로 사용한 Provider와 모델을 설정합니다.
   */
  public setLastUsed(provider: string, model: string): void {
    this.config.lastUsed = { provider, model };
    this.saveConfig();
  }

  /**
   * 마지막으로 사용한 Provider와 모델을 가져옵니다.
   */
  public getLastUsed(): { provider: string; model: string } | undefined {
    return this.config.lastUsed;
  }

  /**
   * 모든 Provider를 가져옵니다.
   */
  public getAllProviders(): Provider[] {
    return this.config.providers;
  }

  /**
   * Provider를 이름으로 가져옵니다.
   */
  public getProviderByName(name: string): Provider | undefined {
    return this.config.providers.find(p => p.name === name);
  }

  /**
   * 언어를 설정합니다.
   */
  public setLanguage(language: Language): void {
    this.config.language = language;
    this.saveConfig();
  }

  /**
   * 현재 언어를 가져옵니다.
   */
  public getLanguage(): Language {
    return this.config.language || 'ko';
  }

  /**
   * 로깅 설정을 가져옵니다.
   * Get logging configuration
   * @returns 로깅 설정 객체
   *
   * Generated by Copilot
   */
  public getLoggingConfig(): LoggingConfig {
    // 설정이 없으면 기본값 생성 및 저장
    if (!this.config.logging) {
      this.config.logging = {
        defaultAiStream: false,
        alwaysVisibleNodes: LOGGER_DEFAULTS.ALWAYS_VISIBLE_NODES.slice()
      };
      this.saveConfig();
    }

    // 항상 복사본 반환하여 외부 수정 방지
    return JSON.parse(JSON.stringify(this.config.logging));
  }

  /**
   * 로깅 설정을 업데이트합니다.
   * Update logging configuration
   * @param loggingConfig 새 로깅 설정
   *
   * Generated by Copilot
   */
  public updateLoggingConfig(loggingConfig: Partial<LoggingConfig>): void {
    // 기존 설정이 없으면 초기화
    if (!this.config.logging) {
      this.config.logging = {
        defaultAiStream: false,
        alwaysVisibleNodes: LOGGER_DEFAULTS.ALWAYS_VISIBLE_NODES.slice()
      };
    }

    // 새 설정 적용
    if (loggingConfig.defaultAiStream !== undefined) {
      this.config.logging.defaultAiStream = loggingConfig.defaultAiStream;
    }

    if (loggingConfig.alwaysVisibleNodes) {
      this.config.logging.alwaysVisibleNodes = loggingConfig.alwaysVisibleNodes;
    }

    this.saveConfig();
  }

  /**
   * 항상 표시할 노드 목록을 설정합니다.
   * Set nodes that are always visible
   * @param nodes 노드 목록
   *
   * Generated by Copilot
   */
  public setAlwaysVisibleNodes(nodes: string[]): void {
    if (!Array.isArray(nodes)) {
      console.error(chalk.red('[ConfigManager] Invalid nodes parameter: expected array'));
      return;
    }

    if (!this.config.logging) {
      this.config.logging = {
        defaultAiStream: false,
        alwaysVisibleNodes: []
      };
    }

    this.config.logging.alwaysVisibleNodes = nodes;
    this.saveConfig();
  }

  /**
   * 기본 AI 스트림 활성화 여부를 설정합니다.
   * Set default AI stream enabled state
   * @param enabled 활성화 여부
   *
   * Generated by Copilot
   */
  public setDefaultAiStream(enabled: boolean): void {
    if (!this.config.logging) {
      this.config.logging = {
        defaultAiStream: enabled,
        alwaysVisibleNodes: LOGGER_DEFAULTS.ALWAYS_VISIBLE_NODES.slice()
      };
    } else {
      this.config.logging.defaultAiStream = enabled;
    }

    this.saveConfig();
  }

  /**
   * 정리 작업을 수행합니다.
   * 인스턴스가 더 이상 필요하지 않을 때 호출하십시오.
   *
   * Generated by Copilot
   */
  public cleanup(): void {
    if (this.watcher) {
      this.watcher.close();
      this.watcher = null;
    }
    this.changeListeners = [];
  }
}